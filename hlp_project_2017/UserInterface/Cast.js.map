{"version":3,"sources":["..\\Cast.fs"],"names":[],"mappings":"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","file":"Cast.js","sourcesContent":["ï»¿namespace ARM7TDMI\r\n\r\nmodule Cast=\r\n    open InstructionType\r\n    open MachineState\r\n\r\n\r\n    /// matches string (X -> X) returning integer\r\n    let (|IsInt|_|) (s:string) = \r\n        try \r\n            int s |> Some\r\n        with _ -> None\r\n\r\n    ///matches string (#X->X) returning integer\r\n    let (|IsLit|_|) (s:string) = \r\n        let getX = s.[1..] \r\n        if s.[0]='#'\r\n        then\r\n            match getX with\r\n            | IsInt x -> Some(x)\r\n            | _ -> None\r\n        else\r\n            None\r\n\r\n    /// matches string returning register\r\n    let (|IsReg|_|) (s:string) =\r\n        let getX = s.[1..] \r\n        //let ParseToReg =\r\n        if s.[0]='R'\r\n        then\r\n            match getX with\r\n            | IsInt x when x<=15 -> R(x) |> Some\r\n            | _ -> None\r\n            //| \"R0\" -> R 0\r\n            //| \"R1\" -> R 1\r\n        else\r\n            None//invalidOp \"register does not exist\"\r\n\r\n\r\n    /// matches RegOrLit string returning the RegOrLit\r\n    let (|IsRegOrLit|_|) =\r\n        function\r\n        | IsReg reg -> Reg(reg) |> Some\r\n        | IsLit lit -> Lit(lit) |> Some\r\n        | _ -> None\r\n\r\n     /// matches string returning string\r\n    let (|IsLabel|_|) = \r\n        function\r\n        | IsReg x -> None\r\n        | s -> \r\n            try \r\n                string s |> Some \r\n            with _ -> None\r\n\r\n    //cast value to addr\r\n    let ValueToAddr (value:Value) =\r\n        match value with\r\n        | (x:int) -> Addr x\r\n    //cast value opttion to addr\r\n    let ValueOptToAddr (value:Option<Value>) =\r\n        match value with\r\n        | Some (x:int) -> Addr x\r\n        | None -> failwith \"R 15 has not been initialized or has been removed\"\r\n    //cast addr to value\r\n    let AddrToValue (addr:Address) =\r\n        match addr with\r\n        | Addr (x:int) -> (x:Value)\r\n\r\n    //check if one branch label returns bool for filter\r\n    let IsBranch =\r\n        function\r\n        | [IsLabel x] -> true\r\n        | _ -> false\r\n    //check if one branch label returns bool for filter\r\n    let IsNotBranch =\r\n        function\r\n        | [IsLabel x] -> false\r\n        | _ -> true\r\n\r\n    //check if instruction is valid\r\n    \r\n    //MOV and MVN\r\n    let (|IsMOVInst|_|)=\r\n        function\r\n        | \"MOV\" -> MOV |> Some\r\n        | \"MVN\" -> MVN |> Some\r\n        | _ -> None\r\n\r\n    //No forget ADR and LDR\r\n\r\n    //ALU\r\n    let (|IsALUInst|_|) =\r\n        function\r\n        | \"ADD\" -> ADD |> Some\r\n        | \"ADC\" -> ADC |> Some\r\n        | \"SUB\" -> SUB |> Some\r\n        | \"SBC\" -> SBC |> Some\r\n        | \"RSB\" -> RSB |> Some\r\n        //| \"RSC\" -> RSC |> Some\r\n        //| \"AND\" -> AND |> Some\r\n        | \"EOR\" -> EOR |> Some\r\n        | \"BIC\" -> BIC |> Some\r\n        | \"ORR\" -> ORR |> Some\r\n        | _ -> None\r\n       \r\n    //Shift\r\n    let (|IsShiftInst|_|) =\r\n        function\r\n        | \"LSL\" -> LSL |> Some\r\n        | \"LSR\" -> LSR |> Some\r\n        | \"ASR\" -> ASR |> Some\r\n        | \"ROR\" -> ROR |> Some\r\n        | _ -> None\r\n    \r\n    //No forget RRX\r\n\r\n    //compare\r\n    let (|IsCOMPInst|_|) =\r\n        function\r\n        | \"CMP\" -> CMP |> Some\r\n        | \"CMN\" -> CMN |> Some\r\n        | \"TST\" -> TST |> Some\r\n        | \"TEQ\" -> TEQ |> Some\r\n        | _ -> None\r\n\r\n    //No forget LDR and STR\r\n\r\n    //No forget LDM and STM\r\n\r\n    let (|IsBranchInst|_|) =\r\n        function\r\n        | \"B\" -> B |> Some\r\n        | \"BL\" -> BL |> Some\r\n        | _ -> None\r\n\r\n    let (|IsSetFlag|_|) =\r\n        function\r\n        | \"S\" -> true |> Some\r\n        | \"\" -> false |> Some\r\n        | _ -> None\r\n\r\n    let (|IsCondition|_|) =\r\n        function\r\n        | \"EQ\" -> EQ |> Some\r\n        | \"NE\" -> NE |> Some \r\n        | \"CS\" -> CS |> Some \r\n        | \"HS\" -> HS |> Some \r\n        | \"CC\" -> CC |> Some \r\n        | \"LO\" -> LO |> Some \r\n        | \"MI\" -> MI |> Some \r\n        | \"PL\" -> PL |> Some \r\n        | \"VS\" -> VS |> Some \r\n        | \"VC\" -> VC |> Some \r\n        | \"HI\" -> HI |> Some \r\n        | \"LS\" -> LS |> Some \r\n        | \"GE\" -> GE |> Some \r\n        | \"LT\" -> LT |> Some \r\n        | \"GT\" -> GT |> Some \r\n        | \"LE\" -> LE |> Some \r\n        | \"AL\" -> AL |> Some \r\n        | \"\" -> NoCond |> Some\r\n        | _ -> None\r\n\r\n    //because of fable we have to do this\r\n    let CondCast =\r\n        function\r\n        | NoCond -> None\r\n        | cond -> cond |> Some\r\n    //No forget DCD, EQU, FILL and END\r\n\r\n    let (|Prefix|_|) (p:string) (s:string) =\r\n        if s.StartsWith(p) then\r\n            Some(s.Substring(p.Length))\r\n        else\r\n            None\r\n\r\n    let checkS (s:string) =\r\n        if s <> \"\"\r\n        then \r\n            if s.[0] ='S'\r\n            then \"S\"\r\n            else \"\"\r\n        else \"\"\r\n    let checkCond (s:string) =\r\n        if s.Length = 2\r\n        then s\r\n        elif s.Length = 3\r\n        then s.[1..2]\r\n        elif s = \"S\"\r\n        then \"\"\r\n        else s\r\n\r\n    let toTuple (inst:string) (rest:string) = [inst; checkS rest; checkCond rest]\r\n\r\n    let TokenizeInst (s:string)=\r\n        match s with\r\n        | Prefix \"MOV\" rest -> toTuple \"MOV\" rest\r\n        | Prefix \"MVN\" rest -> toTuple \"MVN\" rest\r\n        | Prefix \"ADD\" rest -> toTuple \"ADD\" rest\r\n        | Prefix \"ADC\" rest -> toTuple \"ADC\" rest\r\n        | Prefix \"SUB\" rest -> toTuple \"SUB\" rest\r\n        | Prefix \"SBC\" rest -> toTuple \"SBC\" rest\r\n        | Prefix \"RSB\" rest -> toTuple \"RSB\" rest\r\n        | Prefix \"RSC\" rest -> toTuple \"RSC\" rest\r\n        | Prefix \"AND\" rest -> toTuple \"AND\" rest\r\n        | Prefix \"EOR\" rest -> toTuple \"EOR\" rest\r\n        | Prefix \"BIC\" rest -> toTuple \"BIC\" rest\r\n        | Prefix \"ORR\" rest -> toTuple \"ORR\" rest\r\n        | Prefix \"LSL\" rest -> toTuple \"LSL\" rest\r\n        | Prefix \"LSR\" rest -> toTuple \"LSR\" rest\r\n        | Prefix \"ASR\" rest -> toTuple \"ASR\" rest\r\n        | Prefix \"ROR\" rest -> toTuple \"ROR\" rest\r\n        | Prefix \"CMP\" rest -> toTuple \"CMP\" rest\r\n        | Prefix \"CMN\" rest -> toTuple \"CMN\" rest\r\n        | Prefix \"TST\" rest -> toTuple \"TST\" rest\r\n        | Prefix \"TEQ\" rest -> toTuple \"TEQ\" rest\r\n        | Prefix \"B\" rest -> toTuple \"B\" rest\r\n        | Prefix \"B\" rest -> toTuple \"BL\" rest\r\n        | x -> [x; \"\"; \"\"]\r\n   "]}