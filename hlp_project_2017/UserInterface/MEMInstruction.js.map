{"version":3,"sources":["..\\MEMInstruction.fs"],"names":[],"mappings":"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","file":"MEMInstruction.js","sourcesContent":["ï»¿namespace ARM7TDMI\r\n/// ===========================================\r\n/// Memory functions\r\n/// ===========================================\r\nmodule MEMInstruction = \r\n    open InstructionType \r\n    open MachineState\r\n    open EmulatorHelper\r\n    /// ADR: update register with address value\r\n    let private adr state dest addr =  \r\n        \r\n        let newRegMap = Map.add dest addr state.RegMap\r\n        {state with RegMap = newRegMap}\r\n    /// LDR: load register with memory content\r\n    let private ldr state dest source offset autoIndex s  = \r\n        let doLDR =  \r\n            let em = Extractor.extractMemory state\r\n            let newRegMap = \r\n                let loadRegMap = Map.add dest (em (Addr (state.RegMap.[source] + offset))) state.RegMap\r\n                Map.add source (loadRegMap.[source] + autoIndex) loadRegMap \r\n            if (dest = source && autoIndex>0) then {state with State = SyntaxErr \"destination cannot equal source\"}\r\n            else {state with RegMap = newRegMap} \r\n        if (Extractor.isValidAddress state (Addr (state.RegMap.[source] + offset))) then doLDR else {state with State = RunTimeErr \"Address not allocated\"}\r\n    /// LDM: load multiple register with memory content\r\n    let private ldm state dir source regList writeBack  = \r\n        //do LDM function\r\n        let doLdm = \r\n            let em = Extractor.extractMemory state\r\n            let newRegMap,offset = \r\n                match dir with\r\n                | ED | IB -> regList |> Seq.distinct |> List.ofSeq |> List.sort |> List.fold (fun (acc,offset) elem -> (Map.add elem (em (Addr (state.RegMap.[source]+offset+4))) acc),(offset+4)) (state.RegMap,0)\r\n                | FD | IA -> regList |> Seq.distinct |> List.ofSeq |> List.sort |> List.fold (fun (acc,offset) elem -> (Map.add elem (em (Addr (state.RegMap.[source]+offset))) acc),(offset+4)) (state.RegMap,0)\r\n                | EA | DB -> regList |> Seq.distinct |> List.ofSeq |> List.sort |> List.rev |> List.fold (fun (acc,offset) elem -> (Map.add elem (em (Addr (state.RegMap.[source]+offset-4))) acc),(offset-4)) (state.RegMap,0)\r\n                | FA | DA -> regList |> Seq.distinct |> List.ofSeq |> List.sort |> List.rev |> List.fold (fun (acc,offset) elem -> (Map.add elem (em (Addr (state.RegMap.[source]+offset))) acc),(offset-4)) (state.RegMap,0)\r\n            if writeBack then {state with RegMap = (Map.add source (state.RegMap.[source]+offset) newRegMap)}\r\n            else {state with RegMap = newRegMap}\r\n        //check if the addresses being read have been written\r\n        let checkAddresses dir =\r\n            let initialList = [1..List.length regList]\r\n            let isValidAddressFold addr flag = \r\n                match flag with\r\n                | true -> Extractor.isValidAddress state addr\r\n                | false -> false       \r\n            let flag,_ =   \r\n                match dir with\r\n                | ED | IB -> initialList |> List.fold (fun (flag,offset) _ ->  (isValidAddressFold (Addr (state.RegMap.[source]+offset+4)) flag,(offset+4))) (true,0)\r\n                | FD | IA -> initialList |> List.fold (fun (flag,offset) _ -> (isValidAddressFold (Addr (state.RegMap.[source]+offset)) flag,(offset+4))) (true,0)\r\n                | EA | DB -> initialList |> List.fold (fun (flag,offset) _ -> (isValidAddressFold (Addr (state.RegMap.[source]+offset-4)) flag,(offset-4))) (true,0)\r\n                | FA | DA -> initialList |> List.fold (fun (flag,offset) _ -> (isValidAddressFold (Addr (state.RegMap.[source]+offset)) flag,(offset-4))) (true,0)\r\n            if flag then doLdm else {state with State = RunTimeErr \"Address not allocated\"}\r\n        checkAddresses dir\r\n    /// STR: store register contents into memory\r\n    let private str state source dest offset autoIndex s =  \r\n        let newMemMap = Map.add (Addr (state.RegMap.[dest]+offset)) (Val source) state.MemMap\r\n        let newRegMap = Map.add dest (state.RegMap.[dest]+autoIndex) state.RegMap \r\n        {state with MemMap = newMemMap;RegMap = newRegMap}\r\n    /// STM: load multiple register with memory content\r\n    let private stm state dir dest regList writeBack = \r\n        let newMemMap,offset = \r\n            match dir with\r\n                | ED | IB -> regList |> List.rev |> List.fold (fun (acc,offset) elem -> (Map.add (Addr (state.RegMap.[dest]+offset)) (Val (state.RegMap.[elem])) acc),(offset-4)) (state.MemMap,0)\r\n                | FD | IA -> regList |> List.rev |> List.fold (fun (acc,offset) elem -> (Map.add (Addr (state.RegMap.[dest]+offset-4)) (Val (state.RegMap.[elem])) acc),(offset-4)) (state.MemMap,0)\r\n                | EA | DB -> regList |> List.fold (fun (acc,offset) elem -> (Map.add (Addr (state.RegMap.[dest]+offset)) (Val (state.RegMap.[elem])) acc),(offset+4)) (state.MemMap,0)\r\n                | FA | DA -> regList |> List.fold (fun (acc,offset) elem -> (Map.add (Addr (state.RegMap.[dest]+offset+4)) (Val (state.RegMap.[elem])) acc),(offset+4)) (state.MemMap,0)\r\n        let newRegMap = if writeBack then (Map.add dest (state.RegMap.[dest]+offset) state.RegMap) else state.RegMap\r\n        {state with RegMap = newRegMap;MemMap = newMemMap}\r\n    /// execute memory instruction \r\n    let executeInstruction state instruction =      \r\n        let er = Extractor.extractRegister state\r\n        let ga = Extractor.getAddressValue\r\n        match instruction with\r\n            | ADR(r,addr) -> adr state r (ga addr) //Address load  R:=ADDR\r\n            | LDR(r1,r2,offset,autoIndex,b) -> ldr state r1 r2 (er offset) (er autoIndex) b //Load register R1:=[R2]             \r\n            | STR(r1,r2,offset,autoIndex,b) -> str state state.RegMap.[r1] r2 (er offset) (er autoIndex) b //Store register [R2]:=R1\r\n            | LDM(dir,r,regList,wb) -> ldm state dir r regList wb // Load multiple registers \r\n            | STM(dir,r,regList,wb) -> stm state dir r regList wb // Store multiple registers "]}