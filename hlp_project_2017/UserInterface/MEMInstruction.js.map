{"version":3,"sources":["..\\MEMInstruction.fs"],"names":[],"mappings":";;;;;;;;AAUY;AAAY;AAChB;AADa;;AAIT;AAAK;AAAA;AAA6B,SAA7B;;AAAL;AAEiB,+CAAc,GAAI,sCAAM,iCAAN,EAAJ,CAAd;;AACjB,YAAG,oBAAH,EAAuB;AAAA,8CAAgB,kCAAhB;AAA2D,SAAlF;AAAA;AAAA;;AACJ;AAJM;;AAOF;AAAK;AAAA;AAA6B,SAA7B;;AAAL;AAEM;;AAAA;AACkB;AAAA,oEAAqC,oBAAc,GAAI,sCAAM,2CAAN,EAAJ,CAAd,eAArC,EAAqG,gBAArG;AAAA;;AACA;AAAA,wEAAqC,sBAAc,GAAI,sCAAM,yCAAN,EAAJ,CAAd,iBAArC,EAAmG,kBAAnG;AAAA;;AACY;AAAA,wEAAqC,sBAAc,GAAI,sCAAM,6CAAN,EAAJ,CAAd,iBAArC,EAAqG,kBAArG,sBAAZ,2BAAY;AAAA;;AACA;AAAA,wEAAqC,sBAAc,GAAI,sCAAM,yCAAN,EAAJ,CAAd,iBAArC,EAAmG,kBAAnG,sBAAZ,2BAAY;AAAA;AAJ9B;;AAKV,uBAAkB;AAAsB,iDAAgB,0CAAhB;AAAtB;AAA+E,SAAjG,MACK;AAAA;AAA+B;AAR9B;;AAWF;AAAY,wCAAS,sCAAM,+BAAN,EAAT,EAA6C,4CAA7C;AACA,8CAAc,kCAAd;AAChB;AAFa;;AAKT;AAAA;AACM;;AAAA;AACkC;AAAA,oEAAqC,cAAS,sCAAM,qCAAN,EAAT,EAA6C,oCAAK,sBAAL,EAA7C,eAArC,EAAmH,gBAAnH,sBAAZ,2BAAY;AAAA;;AACA;AAAA,wEAAqC,cAAS,sCAAM,2CAAN,EAAT,EAA+C,oCAAK,wBAAL,EAA/C,iBAArC,EAAqH,kBAArH,sBAAZ,2BAAY;AAAA;;AACZ;AAAA,wEAAqC,cAAS,sCAAM,uCAAN,EAAT,EAA6C,oCAAK,wBAAL,EAA7C,iBAArC,EAAmH,kBAAnH;AAAA;;AACA;AAAA,wEAAqC,cAAS,sCAAM,2CAAN,EAAT,EAA+C,oCAAK,wBAAL,EAA/C,iBAArC,EAAqH,kBAArH;AAAA;AAJtB;;AAKM,sCAAmB,oBAAc,wCAAd,eAAnB;AAChB;AAPoB;;AAUhB;AAAK;AAAA;AAA+B,SAA/B;;AACA;AAAA;AAAyB,SAAzB;;AACH,wCAEiC;AAAA,4EAAiB,yBAAjB,EAA6B,yBAA7B;AAA4C,SAF7E,sCAGiC;AAAA,8BAAU,uCAAV,yBAAgC,yBAAhC,EAA4C,yBAA5C;AAA2D,SAH5F,sCAIyB;AAAA;AAA0B,SAJnD,sCAKyB;AAAA;AAA0B,SALnD,MACe;AAAA,qDAAa,yBAAb;AAAqB;AAHpC","file":"MEMInstruction.js","sourcesContent":["ï»¿namespace ARM7TDMI\r\n/// ===========================================\r\n/// Memory functions\r\n/// ===========================================\r\nmodule MEMInstruction = \r\n    open InstructionType \r\n    open MachineState\r\n    open EmulatorHelper\r\n    /// update register with address value\r\n    let private adr state dest exp=  \r\n        let newRegMap = Map.add dest exp state.RegMap\r\n        {state with RegMap = newRegMap}\r\n    /// load register with memory content\r\n    let private ldr state dest source offset autoIndex s  = \r\n        let em = Extractor.extractMemory state\r\n        let newRegMap = \r\n            let loadRegMap = Map.add dest (em (Addr (state.RegMap.[source] + offset))) state.RegMap\r\n            if dest <> source then Map.add source (loadRegMap.[source] + autoIndex) loadRegMap else loadRegMap\r\n        {state with RegMap = newRegMap}\r\n    /// load multiple register with memory content\r\n    let private ldm state dir source regList writeBack  = \r\n        let em = Extractor.extractMemory state\r\n        let newRegMap,offset = \r\n            match dir with\r\n            | ED | IB -> regList |> List.fold (fun (acc,offset) elem -> (Map.add elem (em (Addr (state.RegMap.[source]+offset+4))) acc),(offset+4)) (state.RegMap,0)\r\n            | FD | IA -> regList |> List.fold (fun (acc,offset) elem -> (Map.add elem (em (Addr (state.RegMap.[source]+offset))) acc),(offset+4)) (state.RegMap,0)\r\n            | EA | DB -> regList |> List.rev |> List.fold (fun (acc,offset) elem -> (Map.add elem (em (Addr (state.RegMap.[source]+offset-4))) acc),(offset-4)) (state.RegMap,0)\r\n            | FA | DA -> regList |> List.rev |> List.fold (fun (acc,offset) elem -> (Map.add elem (em (Addr (state.RegMap.[source]+offset))) acc),(offset-4)) (state.RegMap,0)\r\n        if writeBack then {state with RegMap = (Map.add source (state.RegMap.[source]+offset) newRegMap)}\r\n        else {state with RegMap = newRegMap}\r\n    /// store register contents into memory\r\n    let private str state source dest offset autoIndex s =  \r\n        let newMemMap = Map.add (Addr (state.RegMap.[dest]+offset)) (Val source) state.MemMap\r\n        let newRegMap = Map.add dest (state.RegMap.[dest]+autoIndex) state.RegMap \r\n        {state with MemMap = newMemMap;RegMap = newRegMap}\r\n    /// load multiple register with memory content\r\n    let private stm state dir dest regList writeBack = \r\n        let newMemMap,offset = \r\n            match dir with\r\n                | ED | IB -> regList |> List.rev |> List.fold (fun (acc,offset) elem -> (Map.add (Addr (state.RegMap.[dest]+offset)) (Val (state.RegMap.[elem])) acc),(offset-4)) (state.MemMap,0)\r\n                | FD | IA -> regList |> List.rev |> List.fold (fun (acc,offset) elem -> (Map.add (Addr (state.RegMap.[dest]+offset-4)) (Val (state.RegMap.[elem])) acc),(offset-4)) (state.MemMap,0)\r\n                | EA | DB -> regList |> List.fold (fun (acc,offset) elem -> (Map.add (Addr (state.RegMap.[dest]+offset)) (Val (state.RegMap.[elem])) acc),(offset+4)) (state.MemMap,0)\r\n                | FA | DA -> regList |> List.fold (fun (acc,offset) elem -> (Map.add (Addr (state.RegMap.[dest]+offset+4)) (Val (state.RegMap.[elem])) acc),(offset+4)) (state.MemMap,0)\r\n        let newRegMap = if writeBack then (Map.add dest (state.RegMap.[dest]+offset) state.RegMap) else state.RegMap\r\n        {state with RegMap = newRegMap;MemMap = newMemMap}\r\n    /// execute memory instruction \r\n    let executeInstruction state instruction =      \r\n        let er = Extractor.extractRegister state\r\n        let ga = Extractor.getAddressValue\r\n        match instruction with\r\n            | ADR(r,addr) -> adr state r (ga addr) //Address load  R:=ADDR\r\n            | LDR(r1,r2,offset,autoIndex,b) -> ldr state r1 r2 (er offset) (er autoIndex) b //Load register R1:=[R2]             \r\n            | STR(r1,r2,offset,autoIndex,b) -> str state state.RegMap.[r1] r2 (er offset) (er autoIndex) b //Store register [R2]:=R1\r\n            | LDM(dir,r,regList,wb) -> ldm state dir r regList wb // Load multiple registers \r\n            | STM(dir,r,regList,wb) -> stm state dir r regList wb // Store multiple registers "]}