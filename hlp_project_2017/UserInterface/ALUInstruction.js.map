{"version":3,"sources":["..\\ALUInstruction.fs"],"names":[],"mappings":";;;;;;;;AAUY;AAAY;AACD,6BAAU,gDAAgC,+DAAhC,CAAV;AACf;AAFa;;AAKT;AAAY;AACD,6BAAU,gDAAgC,uEAAhC,CAAV;AACf;AAFa;;AAKT;AAAY;AACD,6BAAU,gDAAgC,uEAAhC,CAAV;AACf;AAFa;;AAKT;AAAY;AACD,6BAAU,gDAAgC,yEAAhC,CAAV;AACf;AAFa;;AAKT;AAAK;AAAA;AAA+B,SAA/B;;AACH,wCAEW;AAAA,gEAAuB,CAAI,yBAA3B;AAAoC,SAF/C,sCAGgB;AAAA,gEAAyB,0CAAqB,yBAA9C;AAAwD,SAHxE,sCAIgB;AAAA,gEAAyB,0CAAqB,yBAA9C;AAAwD,SAJxE,sCAKgB;AAAA,gEAAyB,0CAAqB,CAAI,yBAAlD;AAA6D,SAL7E,sCAMgB;AAAA,gEAAyB,0CAAqB,yBAA9C;AAAwD,SANxE,sCAOc;AAAA,qDAAa,uCAAb,EAAgC,yBAAhC,EAAyC,0CAAmB,yBAA5D;AAAuE,SAPrF,sCAQc;AAAA,qDAAa,uCAAb,EAAgC,yBAAhC,EAAyC,0CAAmB,yBAAnB,gBAAzC;AAA4G,SAR1H,sCASc;AAAA,qDAAa,uCAAb,EAAgC,yBAAhC,EAAyC,0CAAmB,yBAA5D;AAAsE,SATpF,sCAUc;AAAA,qDAAc,yBAAd,EAAsB,uCAAtB,EAA0C,yBAAD,GAAS,uCAAlD;AAAsE,SAVpF,sCAWc;AAAA,qDAAc,yBAAd,EAAuB,2DAAvB,EAAoF,yBAAD,GAAS,uCAAT,oBAAnF;AAAwJ,SAXtK,sCAYc;AAAA,qDAAc,uCAAd,EAAmC,yBAAD,oBAAlC,EAAqF,0CAAmB,yBAAnB,oBAArF;AAA0J,SAZxK,MACU;AAAA,gEAAwB,yBAAxB;AAAiC;AAF3C","file":"ALUInstruction.js","sourcesContent":["ï»¿namespace ARM7TDMI\r\n/// ===========================================\r\n/// ALU functions\r\n/// ===========================================\r\nmodule ALUInstruction = \r\n    open InstructionType \r\n    open MachineState\r\n    open EmulatorHelper\r\n    /// update register and set NZ based on new result   \r\n    let private updateRegister state dest op2 s = \r\n        let newRegMap = Map.add dest op2 state.RegMap\r\n        let newFlags = if s then ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.OTHER(op2)) else state.Flags\r\n        {state with RegMap = newRegMap;Flags = newFlags}\r\n    /// update register and set NZCV based on result with addition\r\n    let private add state dest op1 op2 res s = \r\n        let newRegMap = Map.add dest res state.RegMap\r\n        let newFlags = if s then ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.ADD(op1,op2,res)) else state.Flags\r\n        {state with RegMap = newRegMap;Flags = newFlags}\r\n    /// update register and set NZCV based on result with subtraction\r\n    let private sub state dest op1 op2 res s = \r\n        let newRegMap = Map.add dest res state.RegMap\r\n        let newFlags = if s then ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.SUB(op1,op2,res)) else state.Flags\r\n        {state with RegMap = newRegMap;Flags = newFlags}\r\n    /// update register and set NZCV based on result with subtraction\r\n    let private subwc state dest op1 op2 res s = \r\n        let newRegMap = Map.add dest res state.RegMap\r\n        let newFlags = if s then ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.SUBWC(op1,op2,res)) else state.Flags\r\n        {state with RegMap = newRegMap;Flags = newFlags}\r\n    /// execute ALU instruction \r\n    let executeInstruction state instruction s = \r\n        let er = Extractor.extractRegister state\r\n        match instruction with\r\n        | MOV(r,rol) -> updateRegister state r (er rol) s  // R:=ROL\r\n        | MVN(r, rol) -> updateRegister state r ~~~(er rol) s //R:=NOT(ROL) \r\n        | AND(r1, r2, rol) -> updateRegister state r1 (state.RegMap.[r2]&&&(er rol)) s // R1:=R2 EOR ROL\r\n        | EOR(r1, r2, rol) -> updateRegister state r1 (state.RegMap.[r2]^^^(er rol)) s // R1:=R2 EOR ROL\r\n        | BIC(r1, r2, rol) -> updateRegister state r1 (state.RegMap.[r2]&&&(~~~(er rol))) s //R1:=R2 AND NOT(ROL)\r\n        | ORR(r1, r2, rol) -> updateRegister state r1 (state.RegMap.[r2]|||(er rol)) s //R1:= R2 OR ROL\r\n        | ADD(r1,r2,rol) -> add state r1 state.RegMap.[r2] (er rol) (state.RegMap.[r2]+(er rol))  s // R1:=R2+ROL\r\n        | ADC(r1,r2,rol) -> add state r1 state.RegMap.[r2] (er rol) (state.RegMap.[r2]+(er rol)+System.Convert.ToInt32(state.Flags.C)) s //R1:=R2+ROl+C\r\n        | SUB(r1,r2,rol) -> sub state r1 state.RegMap.[r2] (er rol) (state.RegMap.[r2]-(er rol)) s // R1:=R2-ROL\r\n        | RSB(r1,r2,rol) -> sub state r1 (er rol) state.RegMap.[r2] ((er rol)-state.RegMap.[r2]) s //R1:=ROL-R2 \r\n        | RSC(r1,r2,rol) -> sub state r1 (er rol) (state.RegMap.[r2]-System.Convert.ToInt32(state.Flags.C)+1) ((er rol)-state.RegMap.[r2]+System.Convert.ToInt32(state.Flags.C)-1) s //R1:=ROL-R2+C-1\r\n        | SBC(r1,r2,rol) -> sub state r1 (state.RegMap.[r2]) ((er rol)-System.Convert.ToInt32(state.Flags.C)+1) (state.RegMap.[r2]-(er rol)+System.Convert.ToInt32(state.Flags.C)-1) s //R1:=R2-ROL+C-1\r\n\r\n\r\n"]}