{"version":3,"sources":["..\\EmulatorHelper.fs"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAQW;AAEM;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAFN;;AAYK,sDACI;AAAgB;AAAA,oBAAG,OAAH;AAAA;AAAA;AAAA;AAAA;AAA+B,aAA/B;;AACA;AAAA,oBAAG,WAAH;AAAA;AAAA;AAAA;AAAA;AAA+B,aAA/B;;AACd,4CAOiB;AAAA,+CACS,wBADT,EAES,wBAFT,EAIY,0DAAH,eAJT,EAMS,CAAI,CAAC,6BAAS,yBAAT,YAAkB,yBAAlB,QAAD,WAA8B,6BAAS,yBAAT,YAAkB,yBAAlB,QAAlC,gBANT;AAOE,aAdnB,wCAemB;AAAA,+CACO,wBADP,EAEO,wBAFP,EAIO,CAAG,6DAA+B,+CAA/B,QAAH,gBAJP,EAMO,CAAI,CAAC,6BAAS,yBAAT,YAAkB,yBAAlB,QAAD,WAA8B,6BAAS,yBAAT,YAAkB,yBAAlB,QAAlC,gBANP;AAOA,aAtBnB,sCAuBgB;AAAA,+CACc,wBADd,EAEc,wBAFd,EAGc,CAAG,CAAC,yBAAS,eAAgB,yBAAzB,2BAAD,GAA6C,8BAAY,2BAAZ,QAA7C,YAAsE,0BAAtE,QAAH,WAAoG,2BAAH,wBAH/G;AAKO,aA5BvB,sCA8BgB;AAAA,+CACc,wBADd,EAEc,wBAFd,EAIc,CAAG,CAAC,CAAC,wBAAS,KAAO,yBAAjB,MAA6B,KAAO,yBAArC,GAAkD,8BAAY,2BAAZ,QAAlD,YAA2E,0BAA3E,QAAH,WAA0G,2BAAH,wBAJrH;AAMQ,aApCxB,sCAqCgB;AAAA,+CACc,wBADd,EAEc,wBAFd,EAIc,CAAG,CAAC,CAAC,CAAC,wBAAS,KAAO,yBAAjB,MAA6B,KAAO,yBAArC,GAAkD,8BAAY,2BAAZ,QAAlD,YAA2E,0BAA3E,QAAD,WAAwF,6BAAW,yBAAX,QAA3F,WAAiI,2BAAH,wBAJ5I;AAMQ,aA3CxB,sCA4CgB;AAAA,+CACc,wBADd,EAEc,wBAFd,EAIc,CAAI,CAAC,wBAAS,KAAO,8BAAjB,MAAgC,KAAO,8BAAxC,GAAwD,8BAAY,2BAAZ,QAAxD,QAAH,WAAoG,2BAAH,wBAJ/G;AAMS,aAlDzB,wCAmDiB;AAAA,+CACS,wBADT,EAES,wBAFT;AAKE,aAxDnB,MACiB;AAAA,+CAAS,wBAAT,EACS,wBADT,EAGY,6DAAsB,wDAAtB,iDAAH,eAHT,EAKS,CAAG,CAAC,6BAAS,yBAAT,YAAkB,0BAAlB,QAAD,WAA+B,6BAAS,yBAAT,YAAkB,yBAAlB,QAAlC,gBALT;AAK2F;AARjG,SADjB;;AAZL;AAYiB,KAZjB;;AA4EA;AAEC,4DACU;AAAA,oCAEK;AAAA;AAAC,aAFN,MACK;AAAA;AAAgB;AADlB,SADb;;AAKA,0DACU;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyB,SADnC;;AAMA,wDACQ;AACA;AAAA,2CAEY;AAAA,2BAAU,wCAAV;AAAA;AAAA;AAA2B,iBAFvC,MACW;AAAA;AAAC;AAC2B,aAFvC;;AAGJ;AAJkB,SADtB;;AAQA,4DAAiB;AAAA;AAAM,SAAvB;;AArBD;AAqBgB,KArBhB","file":"EmulatorHelper.js","sourcesContent":["ï»¿namespace ARM7TDMI\r\n\r\nmodule EmulatorHelper =\r\n    open InstructionType \r\n    open MachineState\r\n    /// ===========================================\r\n    /// Processing flag functions\r\n    /// ===========================================\r\n    module ProcessFlag =\r\n            /// types for processing flags \r\n            type ProcessFlagType = \r\n                | ADD of Value*Value*Value //op1 op2 result\r\n                | SUB of Value*Value*Value //op1 op2 result\r\n                | SUBWC of Value*Value*Value //op1 op2 result\r\n                | LSL of Value*Value*Value // op1 op2 result\r\n                | LSR of Value*Value*Value // op1 op2 result\r\n                | ASR of Value*Value*Value // op1 op2 result\r\n                | ROR of Value*Value*Value // op1 op2 result\r\n                | OTHER of Value // result\r\n            ///process and return new flags\r\n            let processFlags (state:MachineState) (instruction:ProcessFlagType) =\r\n                let N (res:Value) = if res < 0 then true else false //set if negative\r\n                let Z (res:Value) = if res = 0 then true else false //set if zero\r\n                match instruction with\r\n                | ADD(op1,op2,res) ->  {    N = N res \r\n                                            Z = Z res\r\n                                            //set carry if result is greater than or equal to 2^32\r\n                                            C = if uint64(uint32(op1)) + uint64(uint32(op2)) >= 4294967296UL then true else false \r\n                                            //set overflow if adding two same signed values results in a result of a different sign\r\n                                            V = if (op1<0 && op2<0 && res>=0) || (op1>0 && op2>0 && res< 0) then true else false }\r\n                | SUB(op1,op2,res) ->  { \r\n                                            N = N res \r\n                                            Z = Z res\r\n                                            //set carry if result is >=0   \r\n                                            C = if uint32(op1) >= uint32(op2) then true else false \r\n                                            //set overflow if subtracting +ve from -ve generates a +ve or subtracting -ve from +ve generates a -ve\r\n                                            V = if ((op1>0 && op2<0 && res<0) || (op1<0 && op2>0 && res>0))then true else false\r\n                                        }\r\n                | SUBWC(op1,op2,res) ->  { \r\n                                            N = N res \r\n                                            Z = Z res\r\n                                            //set carry if result is >=0   \r\n                                            C = if uint32(op1) >= uint32(op2) && (op1 <> op2) then true else false \r\n                                            //set overflow if subtracting +ve from -ve generates a +ve or subtracting -ve from +ve generates a -ve\r\n                                            V = if ((op1>0 && op2<0 && res<0) || (op1<0 && op2>0 && res>0))then true else false\r\n                                        }\r\n                | LSL(op1,op2,res) -> {   \r\n                                                N = N res\r\n                                                Z = Z res\r\n                                                C = if (op1 &&& (0x80000000 >>> (op2-1)) = op1) && (op1 <> 0 && op2 <> 0) && op2 <31 then true else (if op2 = 0 then state.Flags.C else false)\r\n                                                V = state.Flags.V\r\n                                            }\r\n                                            \r\n                | LSR(op1,op2,res) -> {\r\n                                                N = N res\r\n                                                Z = Z res\r\n                                                //set carry if 1 is shifted out\r\n                                                C = if ((op1 &&& (1 <<< (op2-1))) = (1 <<< (op2-1))) && (op1 <> 0 && op2 <> 0) && op2 <31  then true else (if op2 = 0 then state.Flags.C else false)\r\n                                                V = state.Flags.V\r\n                                             }\r\n                | ASR(op1,op2,res) -> {\r\n                                                N = N res\r\n                                                Z = Z res\r\n                                                //set carry if 1 is shifted out\r\n                                                C = if (((op1 &&& (1 <<< (op2-1))) = (1 <<< (op2-1))) && (op1 <> 0 && op2 <> 0) && op2<31) || (op2 >31 && op1 <0) then true else (if op2 = 0 then state.Flags.C else false)\r\n                                                V = state.Flags.V\r\n                                             }\r\n                | ROR(op1,op2,res) -> {\r\n                                                N = N res\r\n                                                Z = Z res\r\n                                                //set carry if 1 is shifted out\r\n                                                C = if ((op1 &&& (1 <<< (op2%32-1))) = (1 <<< (op2%32-1))) && (op1 <> 0 && op2 <> 0) then true else (if op2 = 0 then state.Flags.C else false)\r\n                                                V = state.Flags.V\r\n                                              }\r\n                | OTHER(res) ->        {\r\n                                            N = N res\r\n                                            Z = Z res\r\n                                            C = state.Flags.C\r\n                                            V = state.Flags.V\r\n                                        }\r\n    \r\n    /// ===========================================\r\n    /// Extracting functions\r\n    /// ===========================================\r\n    module Extractor = \r\n        /// extract value from register\r\n        let extractRegister (state:MachineState) (rol:RegOrLit) = \r\n                match rol with\r\n                | Reg r -> state.RegMap.[r]\r\n                | Lit l -> l\r\n            /// extract value from memory\r\n        let isValidAddress (state:MachineState) (addr:Address) =\r\n                match state.MemMap.TryFind addr with\r\n                | Some (Val v) -> true\r\n                | Some (Inst i) -> false\r\n                | None -> false\r\n        /// extract value from memory\r\n        let extractMemory (state:MachineState) (addr:Address) =\r\n                let checkValidAddr =\r\n                    function\r\n                    | Val v -> v\r\n                    | Inst i -> failwithf \"invalid address\" \r\n                state.MemMap.[addr]\r\n                |> checkValidAddr\r\n        /// get value of address\r\n        let getAddressValue (Addr a:Address) = a\r\n"]}