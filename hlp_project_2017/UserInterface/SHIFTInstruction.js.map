{"version":3,"sources":["..\\SHIFTInstruction.fs"],"names":[],"mappings":";;;;;;;;AAUY;AAAS,uBAAG,SAAH,OAA0B,UAA1B;AACG;AACD,6BAAU,gDAAgC,0EAAhC,CAAV;AACf;AAHU;;AAMN;AAAM,oBAAG,SAAH,UAA+B,iBAA/B;AACM;AACD,0BAAI,IAAK,QAAL,QAAJ,IAAuB,gDAAgC,uEAAhC,CAAvB;AACf;AAHO;;AAMH;AAAM,qBAAG,WAAW,OAAX,QAAH,SACK,QAAL,OACK,UAFL;AAGM;AACD,6BAAU,gDAAgC,uEAAhC,CAAV;AACf;AALO;;AAQH;AAAO,uBAAO,iBAAD,GAAyB,aAAe,QAA9C;AACK;AACD,6BAAU,gDAAgC,uEAAhC,CAAV;AACf;AAHO;;AAMH;AAAS,0BAAO,eAAD,GAAuB,yBAA7B;AACG;AACL,qBAAG,CAAC,OAAD,OAAH;AAFP;;AAGW,eAAU;AAAC,gFAAgC,kEAAhC;;AAAD;AAA0F,SAApG,MAA0G;AAAA;AAAW;;AACpI;AAJU;;AAON;AAAK;AAAA;AAA+B,SAA/B;;AACU;AAAA;AAAiB,SAAjB;;AACb,wCAEkB;AAAA,sDAAc,uCAAd,EAAiC,UAAW,yBAAX,CAAjC;AAAsD,SAFxE,sCAGkB;AAAA,sDAAc,uCAAd,EAAiC,UAAW,yBAAX,CAAjC;AAAsD,SAHxE,sCAIkB;AAAA,qDAAa,uCAAb,EAAgC,UAAW,yBAAX,CAAhC;AAAqD,SAJvE,sCAKc;AAAA,qDAAa,uCAAb;AAAgC,SAL9C,MACkB;AAAA,sDAAc,uCAAd,EAAiC,UAAW,yBAAX,CAAjC;AAAsD;AAHxE","file":"SHIFTInstruction.js","sourcesContent":["ï»¿namespace ARM7TDMI\r\n/// ===========================================\r\n/// Shift functions\r\n/// ===========================================\r\nmodule SHIFTInstruction =\r\n    open InstructionType \r\n    open MachineState\r\n    open EmulatorHelper\r\n    /// logical shit left\r\n    let private lshl state dest op1 op2 s =  \r\n        let newRes = if op2 >= 31 then 0 else (op1 <<< op2) //if op2 >= 31 then all bits shifted\r\n        let newRegMap = Map.add dest newRes state.RegMap\r\n        let newFlags = if s then ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.LSL(op1,op2,newRes)) else state.Flags\r\n        {state with RegMap = newRegMap;Flags = newFlags}\r\n        /// logical shift right\r\n    let private lshr state dest op1 op2 s = \r\n        let res = if op2 >= 31 then 0 else int32((uint32)op1 >>> op2)  //if op2 >= 31 then all bits shifted\r\n        let newRegMap = Map.add dest res state.RegMap\r\n        let newFlags = if (s && op2 <32) then ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.LSR(op1,op2,res)) else state.Flags\r\n        {state with RegMap = newRegMap;Flags = newFlags}\r\n    /// arithmetic shift right\r\n    let private ashr state dest op1 op2 s = \r\n        let res = if op2>31 && (op1 < 0) then -1 //if op2 >= 31 and op1 is -ve then all bits replaced with 1\r\n                  elif op2>31 then 0 //if op1 is +ve and op2 >=31 then all bits replaced with 0\r\n                  else op1 >>> op2 \r\n        let newRegMap = Map.add dest res state.RegMap\r\n        let newFlags = if s then ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.ASR(op1,op2,res)) else state.Flags\r\n        {state with RegMap = newRegMap;Flags = newFlags}\r\n    /// rotate right \r\n    let private ror state dest op1 op2 s = \r\n        let res =  int32((uint32(op1)>>>op2) ||| (uint32(op1)<<<(32-op2))) //do rotations on logical shifts \r\n        let newRegMap = Map.add dest res state.RegMap\r\n        let newFlags = if s then ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.ROR(op1,op2,res)) else state.Flags\r\n        {state with RegMap = newRegMap;Flags = newFlags}\r\n    /// rotate right with extend\r\n    let private rrx state dest exp s = \r\n        let newExp = int32((uint32(exp)>>>1) ||| (uint32(System.Convert.ToInt32(state.Flags.C))<<<(31))) //do rotate by 1 with logical shift\r\n        let newRegMap = Map.add dest newExp state.RegMap\r\n        let newC = if (exp &&& 1) = 1 then true else false\r\n        let newFlags = if s then {ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.OTHER(newExp)) with C = newC} else state.Flags\r\n        {state with RegMap = newRegMap;Flags = newFlags}\r\n    ///execute shift function\r\n    let executeInstruction state instruction s = \r\n        let er = Extractor.extractRegister state\r\n        let get8lsbit x = (int32((uint8)(x))) //set shift to only the 8 LSB of op2\r\n        match instruction with             \r\n            | LSL(r1,r2,rol) -> lshl state r1 state.RegMap.[r2] (get8lsbit (er rol)) s //logical shift left\r\n            | LSR(r1,r2,rol) -> lshr state r1 state.RegMap.[r2] (get8lsbit (er rol)) s //logical shift right\r\n            | ASR(r1,r2,rol) -> ashr state r1 state.RegMap.[r2] (get8lsbit (er rol)) s //arithmetic shift right\r\n            | ROR(r1,r2,rol) -> ror state r1 state.RegMap.[r2] (get8lsbit (er rol)) s //rotate right\r\n            | RRX(r1,r2) -> rrx state r1 state.RegMap.[r2] s //rotate right and extend\r\n"]}