{"version":3,"sources":["..\\Parser.fs"],"names":[],"mappings":"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","file":"Parser.js","sourcesContent":["ï»¿namespace ARM7TDMI\r\n\r\nmodule Parser=\r\n    open InstructionType\r\n    open MachineState\r\n    open Cast\r\n   \r\n    let whiteSpace = [| ' '; '\\f'; '\\t'; '\\r'; '\\n' |]\r\n\r\n    let readAsm textInput = \r\n        let splitIntoLines (text:string) = \r\n            text.Split [|'\\r'; '\\n'|]\r\n            |> Array.toList\r\n            |> List.filter ((<>) \"\") // delete empty strings generated by default .Split function\r\n        let splitIntoWords (line:string) = \r\n            line.Split whiteSpace\r\n            |> Array.toList\r\n            |> List.filter ((<>) \"\") // delete empty strings generated by default .Split function\r\n\r\n        let lineList = //: string list list = \r\n            textInput\r\n            |> splitIntoLines\r\n            |> List.map splitIntoWords\r\n            |> List.filter ((<>) [])\r\n\r\n        let branch_map =\r\n            let chooseAddr (b:Map<string,Address>) i =\r\n                match lineList.[i] with\r\n                | IsLabel x::IsLabel _::IsReg _::_ -> b.Add(x,(Addr (i*4)))\r\n                | _ -> b   \r\n            seq { 0 .. lineList.Length - 1 } \r\n            |> Seq.fold chooseAddr Map.empty\r\n\r\n        let remove_branch_label line=\r\n            match line with\r\n            | IsLabel _::IsLabel _::IsReg _::_ -> line.Tail\r\n            | x -> x   \r\n\r\n        let executeWordsAsCommand (strlist:string list)= //: InstructionLine\r\n            let instruction = TokenizeInst strlist.[0]\r\n            let basicinstruction = instruction.[0]//instruction.[0..2]\r\n            let setflag = instruction.[1]\r\n                (*if instruction.Length = 4 then (string)instruction.[3]\r\n                elif instruction.Length = 6 then (string)instruction.[3]\r\n                else \"\"*)\r\n            let condition = instruction.[2]\r\n                (*if instruction.Length = 5 then instruction.[3..4]\r\n                elif instruction.Length = 6 then instruction.[4..5]\r\n                else \"\"*)\r\n            let instrline = basicinstruction::setflag::condition::(strlist.Tail)\r\n            match instrline with\r\n            //normal with S or Cond or neither\r\n            | [ IsMOVInst inst; IsSetFlag sf; IsCondition cond; IsReg dest; IsRegOrLit op1 ] -> Line(ALU(inst(dest,op1),sf),None,cond)\r\n            | [ IsALUInst inst; IsSetFlag sf; IsCondition cond; IsReg dest; IsReg op1; IsRegOrLit op2 ] -> Line(ALU(inst(dest,op1,op2),sf),None,cond)\r\n            | [ IsShiftInst inst;  IsSetFlag sf; IsCondition cond;IsReg dest; IsReg op1; IsRegOrLit op2] -> Line(SHIFT(inst(dest,op1,op2),sf),None,cond)\r\n            | [ IsCOMPInst inst; IsSetFlag sf; IsCondition cond;IsReg dest; IsRegOrLit op1] -> Line(SF(inst(dest,op1)),None,cond)\r\n            //| [ IsBranchInst inst; IsCondition cond; IsLabel lab] ->\r\n            // with shifts\r\n            | [ IsMOVInst inst; IsSetFlag sf; IsCondition cond; IsReg dest; IsReg op1; \",\" ; IsShiftInst shiftinst; IsRegOrLit exp] -> Line(ALU(inst(dest,Reg(op1)),sf),shiftinst(op1,op1,exp)|> Some,cond)\r\n            | [ IsALUInst inst; IsSetFlag sf; IsCondition cond; IsReg dest; IsReg op1; IsReg op2 ; \",\" ; IsShiftInst shiftinst; IsRegOrLit exp] -> Line(ALU(inst(dest,op1,Reg(op2)),sf),shiftinst(op2,op2,exp)|> Some,cond)\r\n            | [ IsCOMPInst inst; IsSetFlag sf; IsCondition cond;IsReg dest; IsReg op1 ; \",\" ; IsShiftInst shiftinst; IsRegOrLit exp] -> Line(SF(inst(dest,Reg(op1))),shiftinst(op1,op1,exp)|> Some,cond)\r\n            | x -> failwithf \"Unexpected match in parser: %A\" x\r\n\r\n        let instList = //: InstructionType list = \r\n            lineList\r\n            |> List.map remove_branch_label   \r\n            |> List.map executeWordsAsCommand\r\n\r\n        let init_reg = \r\n            [0..15] |> Seq.map (fun x -> (R x, 0)) |> Map.ofSeq\r\n        \r\n        let init_memory =\r\n            let chooseAddr (m:Map<Address,Memory>) i = m.Add(Addr(i*4),Inst(instList.[i]))\r\n            seq { 0 .. instList.Length - 1 } \r\n            |> Seq.fold chooseAddr Map.empty\r\n\r\n        { \r\n            //PC = Addr 0 // PC is now Reg 15\r\n            END = Addr (4*instList.Length)\r\n            RegMap = init_reg\r\n            MemMap = init_memory\r\n            Flags = {N=false; Z=false; C=false; V=false}\r\n            State = RunOK\r\n        }"]}