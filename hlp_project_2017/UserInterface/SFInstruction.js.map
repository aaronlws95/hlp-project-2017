{"version":3,"sources":["..\\SFInstruction.fs"],"names":[],"mappings":";;;;;;;;AAWY;AAAK;AAAA;AAA+B,SAA/B;;AAEC,sDAEW,gDAAgC,0DAAkC,0CAAoB,yBAAtD,EAAhC,CAFX,gCAGU,gDAAgC,wDAAgC,uCAAhC,EAAkD,yBAAlD,EAA0D,0CAAkB,yBAA5E,EAAhC,CAHV,gCAIW,gDAAgC,wDAAgC,uCAAhC,EAAkD,yBAAlD,EAA0D,0CAAkB,yBAA5E,EAAhC,CAJX,GACU,gDAAgC,0DAAkC,0CAAoB,yBAAtD,EAAhC,CADV;AAKV;AAPM","file":"SFInstruction.js","sourcesContent":["ï»¿namespace ARM7TDMI\r\n\r\n/// ===========================================\r\n/// Set flag functions\r\n/// ===========================================\r\nmodule SFInstruction =         \r\n    open InstructionType \r\n    open MachineState\r\n    open EmulatorHelper\r\n    /// execute set flag instruction\r\n    let executeInstruction state instruction = \r\n        let er = Extractor.extractRegister state\r\n        let newFlags = \r\n            match instruction with\r\n            | TST(r,rol) -> ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.OTHER(state.RegMap.[r]&&&(er rol)))  //R AND ROL\r\n            | TEQ(r, rol) -> ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.OTHER(state.RegMap.[r]^^^(er rol))) // R EOR ROL\r\n            | CMP(r,rol) -> ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.SUB(state.RegMap.[r],(er rol),state.RegMap.[r]-(er rol))) // R-ROL\r\n            | CMN(r, rol) -> ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.ADD(state.RegMap.[r],(er rol),state.RegMap.[r]+(er rol))) // R+ROL\r\n        {state with Flags = newFlags}\r\n\r\n\r\n"]}