{"version":3,"sources":["..\\Emulator.fs"],"names":[],"mappings":";;;;;;;;;AAmBkB;AAAA,uCAEO;AAAA;AAA0C,SAFjD,sCAGO;AAAA;AAA0C,SAHjD,wCAIe;AAAA;AAAkD,SAJjE,yCAKU;AAAA;AAA6C,SALvD,wCAMS;AAAA;AAA4C,SANrD,sCAOG;AAAoB;AAApB;AAA2B,SAP9B,MACS;AAAA;AAA4C;AAD1C;;AASb;AAAiB,gFAAiC,sCAAI,wCAAJ,EAAjC;;AAEX;AAAA;;AAAA;AACE;AAAA;;AACA;AAAA;;AACK;AAAA;;AACA;AAAA;;AACL;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA,gDAAwB;AAAA;AAAqB,qBAA7C;AAAA;AAAA;;AACA;AAAA,iDAAyB;AAAA;AAAoB,qBAA7C;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA,6BAAK,+BAAL;;AACA;AAAA,iDAAyB;AAAA;AAA6B,qBAAtD;AAAA;AAAA;;AACA;AAAA,gDAAwB;AAAA,iCAAK,+BAAL;AAAmC,qBAA3D;AAAA;AAAA;;AAdF;AAAA;;AAAA;AAAA;AAAA;AAAI,SAAJ;;AAiBK,2CAAsB,sDAAtB;AAnBX;AAqBM,uSAMyC;AANzC;AAMwB;AAAiB;AAAuB,SAAvB,GANzC;;AAAA;AAEmC;AAAA;AAAA;;AAEO;AAAA,iDAAoB,0BAA0B,iEAA1B,CAApB;AAAA;;AAE0B;AAAA;AAAA;;AANpE;AAAA,gMAQgD;AAA9B;AARlB;AAQ+B;AAAiB;AAAuB,iBAAvB,GARhD;;AAAA;AAQ2E;AAAA,yDAAoB,0BAA0B,iEAA1B,CAApB;AAAA;;AAR3E;AAAA,iKAUsC;AAVtC;AAUqB;AAAiB;AAAwB,yBAAxB,GAVtC;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAYI;AAAoB,gGAAW,0CAAwC,oBAAC,kBAAqB,wCAArB,eAAD,CAAnD;AAApB;AAAA;;AACiC;AAAoB;AAApB;AAAA;;AACpC;AAAoB,kGAAW,mCAAiC,8BAA5C;AAApB;AAAA;AAdD;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AArBN;AAsCM,kDAAoB,wCAApB;;AAAA,YACI,eAAK,iBAAc,wCAAd,CADT,EACgC;AAAA,sCAAS,wCAAT,EAAgB,cAAhB;AAAwC,SADxE,MAEC;AAAA;AAAkB;;AAGvB,mEAAK,cAAW,wCAAX,CAAL;;AAAA,YACG,0BAAqB,uCAArB,CADH;AAAA;AAAA,mBAEI,4CAFJ,EAE6B;AAA8C;AAA9C;AAAqD,SAFlF,MAGC;AAAA;AAAqC;AA9C1B","file":"Emulator.js","sourcesContent":["namespace ARM7TDMI\r\n\r\n\r\nmodule Emulator = \r\n    open InstructionType \r\n    open MachineState\r\n    open ALUInstruction\r\n    open SFInstruction\r\n    open MEMInstruction\r\n    open SHIFTInstruction\r\n    open BRANCHInstruction\r\n    open EmulatorHelper\r\n\r\n    /// ===========================================\r\n    /// Emulator functions\r\n    /// ===========================================\r\n    module Instruction = \r\n        /// main execute instruction function\r\n        let executeInstruction state instruction = \r\n            match instruction with \r\n            | ALU(ai,s) -> ALUInstruction.executeInstruction state ai s \r\n            | SF(sfi) -> SFInstruction.executeInstruction state sfi \r\n            | MEM(mi) -> MEMInstruction.executeInstruction state mi \r\n            | SHIFT(shifti,s) -> SHIFTInstruction.executeInstruction state shifti s \r\n            | BRANCH(bi) -> BRANCHInstruction.executeInstruction state bi \r\n            | LABEL(li) -> LABELInstruction.executeInstruction state li\r\n            | END -> {state with State = RunEND}\r\n        let executeLine state = \r\n            let programCounter = Extractor.extractRegister state (Reg(R 15)) // Program counter is R15\r\n            let checkCondition cond = \r\n                match cond with\r\n                | EQ -> state.Flags.Z = true\r\n                | NE -> state.Flags.Z = false\r\n                | CS | HS -> state.Flags.C = true\r\n                | CC | LO -> state.Flags.C = false\r\n                | MI -> state.Flags.N = true\r\n                | PL -> state.Flags.N = false\r\n                | VS -> state.Flags.V = true\r\n                | VC -> state.Flags.V = false\r\n                | HI -> state.Flags.C = true && state.Flags.Z = false\r\n                | LS -> state.Flags.C = false && state.Flags.Z = true\r\n                | GE -> state.Flags.N = state.Flags.V\r\n                | LT -> not (state.Flags.N = state.Flags.V)\r\n                | GT -> state.Flags.Z = false && state.Flags.N = state.Flags.V\r\n                | LE -> state.Flags.Z = true && not (state.Flags.N = state.Flags.V)\r\n                | AL -> true\r\n                | NoCond -> true \r\n            let instLine = state.MemMap.TryFind( Addr(programCounter) )\r\n            let outputState = \r\n                match instLine with\r\n                // Shift:None, Condition:None\r\n                | Some (Inst(Line(inst, None, None))) -> executeInstruction state inst\r\n                // Shift:Some, Condition:None\r\n                | Some (Inst(Line(inst, Some(sInst), None))) -> executeInstruction (executeInstruction state (SHIFT(sInst,false))) inst\r\n                // Shift:None, Condition:True\r\n                | Some (Inst(Line(inst, None, Some(c) ))) when checkCondition c = true -> executeInstruction state inst \r\n                // Shift:Some, Condition:True\r\n                | Some (Inst(Line(inst, Some(sInst), Some(c) ))) when checkCondition c = true -> executeInstruction (executeInstruction state (SHIFT(sInst,false))) inst\r\n                // Shift:None/Some, Condition:False\r\n                | Some (Inst(Line(inst, _, Some(c) ))) when checkCondition c = false -> state \r\n                // Error cases\r\n                | None -> {state with State = RunTimeErr(\"No instruction line found at address \"+(state.RegMap.TryFind(R 15)).ToString())}\r\n                | Some(Inst(Failed_Parsing(error_msg))) -> {state with State = SyntaxErr(error_msg)}\r\n                | x -> {state with State = RunTimeErr(\"Instruction line not defined: \"+x.ToString())}\r\n            // Update PC \r\n            let newRegMap = \r\n                match outputState.RegMap.[R 15] with\r\n                | pc when pc = state.RegMap.[R 15] -> Map.add (R 15) (pc+4) outputState.RegMap\r\n                | _ -> outputState.RegMap // If PC has been changed, it means a branching operation has taken care of PC for us so no need +4\r\n\r\n            // Check if we have reached the end\r\n            match Addr(newRegMap.[R 15]) with\r\n            | _ when outputState.State <> RunOK -> outputState\r\n            | pc when pc >= outputState.END -> {outputState with RegMap = newRegMap; State = RunEND}\r\n            | _ -> {outputState with RegMap = newRegMap}"]}