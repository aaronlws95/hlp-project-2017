{"version":3,"sources":["..\\Emulator.fs"],"names":[],"mappings":";;;;;;;;;AAiBkB;AAAA,wCACS;AAAA;AAA4C,SADrD,qCAEO;AAAA;AAA0C,SAFjD,sCAGO;AAAA;AAA0C,SAHjD,wCAIe;AAAA;AAAkD,SAJjE;AAAA;AAAW;AAAA;;AAMb;AAAiB,gFAAiC,sCAAI,wCAAJ,EAAjC;;AAEX;AAAA;;AAAA;AACE;AAAA;;AACA;AAAA;;AACK;AAAA;;AACA;AAAA;;AACL;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA,gDAAwB;AAAA;AAAqB,qBAA7C;AAAA;AAAA;;AACA;AAAA,iDAAyB;AAAA;AAAoB,qBAA7C;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA,6BAAK,+BAAL;;AACA;AAAA,iDAAyB;AAAA;AAA6B,qBAAtD;AAAA;AAAA;;AACA;AAAA,gDAAwB;AAAA,iCAAK,+BAAL;AAAmC,qBAA3D;AAAA;AAAA;;AAdF;AAAA;;AAAA;AAAA;AAAA;AAAI,SAAJ;;AAgBK,2CAAsB,sDAAtB;AAlBX;AAoBM,iQAMyC;AANzC;AAMwB;AAAiB;AAAuB,SAAvB,GANzC;;AAAA;AAEmC;AAAA;AAAA;;AAEO;AAAA,iDAAoB,0BAA0B,gEAA1B,CAApB;AAAA;;AAE0B;AAAA;AAAA;;AANpE;AAAA,2JAQgD;AAA9B;AARlB;AAQ+B;AAAiB;AAAuB,iBAAvB,GARhD;;AAAA;AAQ2E;AAAA,yDAAoB,0BAA0B,iEAA1B,CAApB;AAAA;;AAR3E;AAAA,4HAUsC;AAVtC;AAUqB;AAAiB;AAAwB,yBAAxB,GAVtC;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,sDAYI;AAAA,kDAAU,gFAAV;AAAA;AAAA,uCAAqE,kBAAqB,wCAArB,eAArE;AAAgG,iCAZpG,MAaC;AAAA,kDAAU,wEAAV;AAAA;AAAA;AAA6D;;AAb9D;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AApBN;AAoCM,kDAAoB,wCAApB;;AAAA,YACI,eAAK,iBAAc,wCAAd,CADT,EACgC;AAAA,sCAAS,wCAAT,EAAgB,cAAhB;AAAwC,SADxE,MAEC;AAAA;AAAkB;;AAEvB,mEAAK,cAAW,wCAAX,CAAL;;AAAA,YACI,4CADJ,EAC6B;AAA8C;AAA9C;AAAqD,SADlF,MAEC;AAAA;AAAqC;AA1C1B","file":"Emulator.js","sourcesContent":["namespace ARM7TDMI\r\n\r\n\r\nmodule Emulator = \r\n    open InstructionType \r\n    open MachineState\r\n    open ALUInstruction\r\n    open SFInstruction\r\n    open MEMInstruction\r\n    open SHIFTInstruction\r\n    open EmulatorHelper\r\n    /// ===========================================\r\n    /// Emulator functions\r\n    /// ===========================================\r\n    module Instruction = \r\n        /// main execute instruction function\r\n        let executeInstruction state instruction = \r\n            match instruction with \r\n            | ALU(ai,s) -> ALUInstruction.executeInstruction state ai s \r\n            | SF(sfi) -> SFInstruction.executeInstruction state sfi \r\n            | MEM(mi) -> MEMInstruction.executeInstruction state mi \r\n            | SHIFT(shifti,s) -> SHIFTInstruction.executeInstruction state shifti s \r\n        let executeLine state = \r\n            let programCounter = Extractor.extractRegister state (Reg(R 15)) // Program counter is R15\r\n            let checkCondition cond = \r\n                match cond with\r\n                | EQ -> state.Flags.Z = true\r\n                | NE -> state.Flags.Z = false\r\n                | CS | HS -> state.Flags.C = true\r\n                | CC | LO -> state.Flags.C = false\r\n                | MI -> state.Flags.N = true\r\n                | PL -> state.Flags.N = false\r\n                | VS -> state.Flags.V = true\r\n                | VC -> state.Flags.V = false\r\n                | HI -> state.Flags.C = true && state.Flags.Z = false\r\n                | LS -> state.Flags.C = false && state.Flags.Z = true\r\n                | GE -> state.Flags.N = state.Flags.V\r\n                | LT -> not (state.Flags.N = state.Flags.V)\r\n                | GT -> state.Flags.Z = false && state.Flags.N = state.Flags.V\r\n                | LE -> state.Flags.Z = true && not (state.Flags.N = state.Flags.V)\r\n                | AL -> true\r\n            let instLine = state.MemMap.TryFind( Addr(programCounter) )\r\n            let outputState = \r\n                match instLine with\r\n                // Shift:None, Condition:None\r\n                | Some (Inst(Line(inst, None, None))) -> executeInstruction state inst\r\n                // Shift:Some, Condition:None\r\n                | Some (Inst(Line(inst, Some(sInst), None))) -> executeInstruction (executeInstruction state (SHIFT(sInst,false))) inst\r\n                // Shift:None, Condition:True\r\n                | Some (Inst(Line(inst, None, Some(c) ))) when checkCondition c = true -> executeInstruction state inst \r\n                // Shift:Some, Condition:True\r\n                | Some (Inst(Line(inst, Some(sInst), Some(c) ))) when checkCondition c = true -> executeInstruction (executeInstruction state (SHIFT(sInst,false))) inst\r\n                // Shift:None/Some, Condition:False\r\n                | Some (Inst(Line(inst, _, Some(c) ))) when checkCondition c = false -> state \r\n                // Error cases\r\n                | None -> failwithf \"run time error: no instruction line found at address %A\" (state.RegMap.TryFind(R 15)) \r\n                | x -> failwithf \"run time error: instruction line not defined %A\" x \r\n            // Update PC \r\n            let newRegMap = \r\n                match outputState.RegMap.[R 15] with\r\n                | pc when pc = state.RegMap.[R 15] -> Map.add (R 15) (pc+4) outputState.RegMap\r\n                | _ -> outputState.RegMap // If PC has been changed, it means a branching operation has taken care of PC for us so no need +4\r\n            // Check if we have reached the end\r\n            match Addr(newRegMap.[R 15]) with\r\n            | pc when pc >= outputState.END -> {outputState with RegMap = newRegMap; State = RunEND}\r\n            | _ -> {outputState with RegMap = newRegMap}"]}