{"version":3,"sources":["..\\Emulator.fs"],"names":[],"mappings":"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","file":"Emulator.js","sourcesContent":["namespace ARM7TDMI\r\n\r\n\r\nmodule Emulator = \r\n    open InstructionType \r\n    open MachineState\r\n\r\n    /// ===========================================\r\n    /// Processing flag functions\r\n    /// ===========================================\r\n    module ProcessFlag =\r\n            /// types for processing flags \r\n            type ProcessFlagType = \r\n                | ADD of Value*Value*Value //op1 op2 result\r\n                | SUB of Value*Value*Value //op1 op2 result\r\n                | SUBWC of Value*Value*Value //op1 op2 result\r\n                | LEFTSHIFT of Value*Value*Value // op1 op2 result\r\n                | RIGHTSHIFT of Value*Value*Value // op1 op2 result\r\n                | OTHER of Value // result\r\n            ///process and return new flags\r\n            let processFlags (state:MachineState) (instruction:ProcessFlagType) =\r\n                let N (res:Value) = if res < 0 then true else false //set if negative\r\n                let Z (res:Value) = if res = 0 then true else false //set if zero\r\n                match instruction with\r\n                | ADD(op1,op2,res) ->  {    N = N res \r\n                                            Z = Z res\r\n                                            //set carry if result is greater than or equal to 2^32\r\n                                            C = if uint64(uint32(op1)) + uint64(uint32(op2)) >= 4294967296UL then true else false \r\n                                            //set overflow if adding two same signed values results in a result of a different sign\r\n                                            V = if (op1<0 && op2<0 && res>=0) || (op1>0 && op2>0 && res< 0) then true else false }\r\n                | SUB(op1,op2,res) ->  { \r\n                                            N = N res \r\n                                            Z = Z res\r\n                                            //set carry if result is >=0   \r\n                                            C = if (op1 >= op2 && res<=op1) || op1 = op2 then true else false \r\n                                            //set overflow if subtracting +ve from -ve generates a +ve or subtracting -ve from +ve generates a -ve\r\n                                            V = if ((op1>0 && op2<0 && res<0) || (op1<0 && op2>0 && res>0))then true else false\r\n                                        }\r\n                | SUBWC(op1,op2,res) -> {   N = N res \r\n                                            Z = Z res\r\n                                            //set carry if result is greater than or equal to 2^32\r\n                                            C = if (op1+System.Convert.ToInt32(state.Flags.C)-1 >= op2  && res<=op1+System.Convert.ToInt32(state.Flags.C)-1) || op1 + System.Convert.ToInt32(state.Flags.C)- 1 = op2   then true else false  \r\n                                            //set overflow if adding two same signed values results in a result of a different sign\r\n                                            V = if ((op1>0 && op2<0 && res<0) || (op1<0 && op2>0 && res>0)) then true else false }\r\n                | LEFTSHIFT(op1,op2,res) -> {   \r\n                                                N = N res\r\n                                                Z = Z res\r\n                                                C = if ((op1 &&& (0x80000000 >>> (op2-1))) = op1) && (op1 <> 0 && op2 <> 0) then true else false\r\n                                                V = state.Flags.V\r\n                                            }\r\n                | RIGHTSHIFT(op1,op2,res) -> {\r\n                                                N = N res\r\n                                                Z = Z res\r\n                                                //set carry if 1 is shifted out\r\n                                                C = if ((op1 &&& (1 <<< (op2-1))) = op1) && (op1 <> 0 && op2 <> 0) then true else false\r\n                                                V = state.Flags.V\r\n                                             }\r\n                | OTHER(res) ->        {\r\n                                            N = N res\r\n                                            Z = Z res\r\n                                            C = state.Flags.C\r\n                                            V = state.Flags.V\r\n                                        }\r\n    \r\n    /// ===========================================\r\n    /// Extracting functions\r\n    /// ===========================================\r\n    module Extractor = \r\n        /// extract value from register\r\n        let extractRegister (state:MachineState) (rol:RegOrLit) = \r\n                match rol with\r\n                | Reg r -> state.RegMap.[r]\r\n                | Lit l -> l\r\n        /// extract value from memory\r\n        let extractMemory (state:MachineState) (addr:Address) =\r\n                let checkValidAddr =\r\n                    function\r\n                    | Val v -> v\r\n                    | Inst i -> failwithf \"invalid address\" \r\n                state.MemMap.[addr]\r\n                |> checkValidAddr\r\n        /// get value of address\r\n        let getAddressValue (Addr a:Address) = a\r\n\r\n    /// ===========================================\r\n    /// ALU functions\r\n    /// ===========================================\r\n    module ALUInstruction = \r\n        /// update register and set NZ based on new result   \r\n        let private updateRegister state dest op2 s = \r\n            let newRegMap = Map.add dest op2 state.RegMap\r\n            let newFlags = if s then ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.OTHER(op2)) else state.Flags\r\n            {state with RegMap = newRegMap;Flags = newFlags}\r\n        /// update register and set NZCV based on result with addition\r\n        let private add state dest op1 op2 res s = \r\n            let newRegMap = Map.add dest res state.RegMap\r\n            let newFlags = if s then ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.ADD(op1,op2,res)) else state.Flags\r\n            {state with RegMap = newRegMap;Flags = newFlags}\r\n        /// update register and set NZCV based on result with subtraction\r\n        let private sub state dest op1 op2 res s = \r\n            let newRegMap = Map.add dest res state.RegMap\r\n            let newFlags = if s then ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.SUB(op1,op2,res)) else state.Flags\r\n            {state with RegMap = newRegMap;Flags = newFlags}\r\n        /// update register and set NZCV based on result with subtraction with carry\r\n        let private subwc state dest op1 op2 res s = \r\n            let newRegMap = Map.add dest res state.RegMap\r\n            let newFlags = if s then ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.SUBWC(op1,op2,res)) else state.Flags\r\n            {state with RegMap = newRegMap;Flags = newFlags}\r\n        /// execute ALU instruction \r\n        let executeInstruction state instruction s = \r\n            let er = Extractor.extractRegister state\r\n            match instruction with\r\n            | MOV(r,rol) -> updateRegister state r (er rol) s  // R:=ROL\r\n            | ADD(r1,r2,rol) -> add state r1 state.RegMap.[r2] (er rol) (state.RegMap.[r2]+(er rol))  s // R1:=R2+ROL\r\n            | SUB(r1,r2,rol) -> sub state r1 state.RegMap.[r2] (er rol) (state.RegMap.[r2]-(er rol)) s // R1:=R2-ROL\r\n            | MVN(r, rol) -> updateRegister state r ~~~(er rol) s //R:=NOT(ROL)\r\n            | EOR(r1, r2, rol) -> updateRegister state r1 (state.RegMap.[r2]^^^(er rol)) s // R1:=R2 EOR ROL\r\n            | RSB(r1,r2,rol) -> sub state r1 (er rol) state.RegMap.[r2] ((er rol)-state.RegMap.[r2]) s //R1:=ROL-R2 \r\n            | RSC(r1,r2,rol) -> subwc state r1 (er rol) state.RegMap.[r2] ((er rol)-state.RegMap.[r2]+System.Convert.ToInt32(state.Flags.C)-1) s //R1:=ROL-R2+C-1\r\n            | ADC(r1,r2,rol) -> add state r1 state.RegMap.[r2] (er rol) (state.RegMap.[r2]+(er rol)+System.Convert.ToInt32(state.Flags.C)) s //R1:=R2+ROl+C\r\n            | SBC(r1,r2,rol) -> subwc state r1 state.RegMap.[r2] (er rol) (state.RegMap.[r2]-(er rol)+System.Convert.ToInt32(state.Flags.C)-1) s //R1:=R2-ROL+C-1\r\n            | BIC(r1, r2, rol) -> updateRegister state r1 (state.RegMap.[r2]&&&(~~~(er rol))) s //R1:=R2 AND NOT(ROL)\r\n            | ORR(r1, r2, rol) -> updateRegister state r1 (state.RegMap.[r2]|||(er rol)) s //R1:= R2 OR ROL\r\n\r\n    /// ===========================================\r\n    /// Set flag functions\r\n    /// ===========================================\r\n    module SFInstruction =         \r\n        /// execute set flag instruction\r\n        let executeInstruction state instruction = \r\n            let er = Extractor.extractRegister state\r\n            let newFlags = \r\n                match instruction with\r\n                | TST(r,rol) -> ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.OTHER(state.RegMap.[r]&&&(er rol)))  //R AND ROL\r\n                | TEQ(r, rol) -> ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.OTHER(state.RegMap.[r]^^^(er rol))) // R EOR ROL\r\n                | CMP(r,rol) -> ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.SUB(state.RegMap.[r],(er rol),state.RegMap.[r]-(er rol))) // R-ROL\r\n                | CMN(r, rol) -> ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.ADD(state.RegMap.[r],(er rol),state.RegMap.[r]+(er rol))) // R+ROL\r\n            {state with Flags = newFlags}\r\n\r\n    /// ===========================================\r\n    /// Memory functions\r\n    /// ===========================================\r\n    module MEMInstruction = \r\n        /// update register with address value\r\n        let private adr state dest exp=  \r\n            let newRegMap = Map.add dest exp state.RegMap\r\n            {state with RegMap = newRegMap}\r\n        /// load register with memory content\r\n        let private ldr state dest source offset autoIndex s  = \r\n            let em = Extractor.extractMemory state\r\n            let newRegMap = \r\n                let loadRegMap = Map.add dest (em (Addr (state.RegMap.[source] + offset))) state.RegMap\r\n                if dest <> source then Map.add source (loadRegMap.[source] + autoIndex) loadRegMap else loadRegMap\r\n            {state with RegMap = newRegMap}\r\n        /// load multiple register with memory content\r\n        let private ldm state dir source regList writeBack  = \r\n            let em = Extractor.extractMemory state\r\n            let newRegMap,offset = \r\n                match dir with\r\n                | ED | IB -> regList |> List.fold (fun (acc,offset) elem -> (Map.add elem (em (Addr (state.RegMap.[source]+offset+4))) acc),(offset+4)) (state.RegMap,0)\r\n                | FD | IA -> regList |> List.fold (fun (acc,offset) elem -> (Map.add elem (em (Addr (state.RegMap.[source]+offset))) acc),(offset+4)) (state.RegMap,0)\r\n                | EA | DB -> regList |> List.rev |> List.fold (fun (acc,offset) elem -> (Map.add elem (em (Addr (state.RegMap.[source]+offset-4))) acc),(offset-4)) (state.RegMap,0)\r\n                | FA | DA -> regList |> List.rev |> List.fold (fun (acc,offset) elem -> (Map.add elem (em (Addr (state.RegMap.[source]+offset))) acc),(offset-4)) (state.RegMap,0)\r\n            if writeBack then {state with RegMap = (Map.add source (state.RegMap.[source]+offset) newRegMap)}\r\n            else {state with RegMap = newRegMap}\r\n        /// store register contents into memory\r\n        let private str state source dest offset autoIndex s =  \r\n            let newMemMap = Map.add (Addr (state.RegMap.[dest]+offset)) (Val source) state.MemMap\r\n            let newRegMap = Map.add dest (state.RegMap.[dest]+autoIndex) state.RegMap \r\n            {state with MemMap = newMemMap;RegMap = newRegMap}\r\n        /// load multiple register with memory content\r\n        let private stm state dir dest regList writeBack = \r\n            let newMemMap,offset = \r\n                match dir with\r\n                    | ED | IB -> regList |> List.rev |> List.fold (fun (acc,offset) elem -> (Map.add (Addr (state.RegMap.[dest]+offset)) (Val (state.RegMap.[elem])) acc),(offset-4)) (state.MemMap,0)\r\n                    | FD | IA -> regList |> List.rev |> List.fold (fun (acc,offset) elem -> (Map.add (Addr (state.RegMap.[dest]+offset-4)) (Val (state.RegMap.[elem])) acc),(offset-4)) (state.MemMap,0)\r\n                    | EA | DB -> regList |> List.fold (fun (acc,offset) elem -> (Map.add (Addr (state.RegMap.[dest]+offset)) (Val (state.RegMap.[elem])) acc),(offset+4)) (state.MemMap,0)\r\n                    | FA | DA -> regList |> List.fold (fun (acc,offset) elem -> (Map.add (Addr (state.RegMap.[dest]+offset+4)) (Val (state.RegMap.[elem])) acc),(offset+4)) (state.MemMap,0)\r\n            let newRegMap = if writeBack then (Map.add dest (state.RegMap.[dest]+offset) state.RegMap) else state.RegMap\r\n            {state with RegMap = newRegMap;MemMap = newMemMap}\r\n        /// execute memory instruction \r\n        let executeInstruction state instruction =      \r\n            let er = Extractor.extractRegister state\r\n            let ga = Extractor.getAddressValue\r\n            match instruction with\r\n                | ADR(r,addr) -> adr state r (ga addr) //Address load  R:=ADDR\r\n                | LDR(r1,r2,offset,autoIndex,b) -> ldr state r1 r2 (er offset) (er autoIndex) b //Load register R1:=[R2]             \r\n                | STR(r1,r2,offset,autoIndex,b) -> str state state.RegMap.[r1] r2 (er offset) (er autoIndex) b //Store register [R2]:=R1\r\n                | LDM(dir,r,regList,wb) -> ldm state dir r regList wb // Load multiple registers \r\n                | STM(dir,r,regList,wb) -> stm state dir r regList wb // Store multiple registers \r\n\r\n    /// ===========================================\r\n    /// Shift functions\r\n    /// ===========================================\r\n    module SHIFTInstruction =\r\n        /// move bits to the right and set NZC based on new result \r\n        let private shiftRight state dest op1 op2 res s =  \r\n            let newRegMap = Map.add dest res state.RegMap\r\n            let newFlags = if s then ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.RIGHTSHIFT(state.RegMap.[op1],op2,res)) else state.Flags\r\n            {state with RegMap = newRegMap;Flags = newFlags}\r\n        /// move bits to the left and set NZC based on new result \r\n        let private shiftLeft state dest op1 op2 res s =  \r\n            let newRegMap = Map.add dest res state.RegMap\r\n            let newFlags = if s then ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.LEFTSHIFT(state.RegMap.[op1],op2,res)) else state.Flags\r\n            {state with RegMap = newRegMap;Flags = newFlags}\r\n        /// rotate right with extend\r\n        let private rrx state dest exp s = \r\n            let newExp = (exp >>> 1) + (System.Convert.ToInt32(state.Flags.C) <<< 31)\r\n            let newRegMap = Map.add dest newExp state.RegMap\r\n            let newC = if (exp &&& 1) = 1 then true else false\r\n            let newFlags = if s then {ProcessFlag.processFlags state (ProcessFlag.ProcessFlagType.OTHER(newExp)) with C = newC} else state.Flags\r\n            {state with RegMap = newRegMap;Flags = newFlags}\r\n        ///execute shift function\r\n        let executeInstruction state instruction s = \r\n            let er = Extractor.extractRegister state\r\n            match instruction with\r\n                | LSL(r1,r2,rol) -> shiftLeft state r1 r2 (er rol) (state.RegMap.[r2] <<< (er rol)) s //logical shift left\r\n                | LSR(r1,r2,rol) -> shiftRight state r1 r2 (er rol) ((int32)((uint32)state.RegMap.[r2] >>> (er rol))) s //logical shift right\r\n                | ASR(r1,r2,rol) -> shiftRight state r1 r2 (er rol) (state.RegMap.[r2] >>> (er rol)) s //arithmetic shift right\r\n                | ROR(r1,r2,rol) -> shiftRight state r1 r2 (er rol) ((state.RegMap.[r2]>>>(er rol)) ||| (state.RegMap.[r2]<<<(32-(er rol)))) s //rotate right\r\n                | RRX(r1,r2) -> rrx state r1 state.RegMap.[r2] s //rotate right and extend\r\n\r\n    /// ===========================================\r\n    /// Instruction functions\r\n    /// ===========================================\r\n    module Instruction = \r\n        /// main execute instruction function\r\n        let executeInstruction state instruction = \r\n            match instruction with \r\n            | ALU(ai,s) -> ALUInstruction.executeInstruction state ai s \r\n            | SF(sfi) -> SFInstruction.executeInstruction state sfi \r\n            | MEM(mi) -> MEMInstruction.executeInstruction state mi \r\n            | SHIFT(shifti,s) -> SHIFTInstruction.executeInstruction state shifti s \r\n        let executeLine state = \r\n            let programCounter = Extractor.extractRegister state (Reg(R 15)) // Program counter is R15\r\n            let checkCondition cond = \r\n                match cond with\r\n                | EQ -> state.Flags.Z = true\r\n                | NE -> state.Flags.Z = false\r\n                | CS | HS -> state.Flags.C = true\r\n                | CC | LO -> state.Flags.C = false\r\n                | MI -> state.Flags.N = true\r\n                | PL -> state.Flags.N = false\r\n                | VS -> state.Flags.V = true\r\n                | VC -> state.Flags.V = false\r\n                | HI -> state.Flags.C = true && state.Flags.Z = false\r\n                | LS -> state.Flags.C = false && state.Flags.Z = true\r\n                | GE -> state.Flags.N = state.Flags.V\r\n                | LT -> not (state.Flags.N = state.Flags.V)\r\n                | GT -> state.Flags.Z = false && state.Flags.N = state.Flags.V\r\n                | LE -> state.Flags.Z = true && not (state.Flags.N = state.Flags.V)\r\n                | AL -> true\r\n            let instLine = state.MemMap.TryFind( Addr(programCounter) )\r\n            let outputState = \r\n                match instLine with\r\n                // Shift:None, Condition:None\r\n                | Some (Inst(Line(inst, None, None))) -> executeInstruction state inst\r\n                // Shift:Some, Condition:None\r\n                | Some (Inst(Line(inst, Some(sInst), None))) -> executeInstruction (executeInstruction state (SHIFT(sInst,false))) inst\r\n                // Shift:None, Condition:True\r\n                | Some (Inst(Line(inst, None, Some(c) ))) when checkCondition c = true -> executeInstruction state inst \r\n                // Shift:Some, Condition:True\r\n                | Some (Inst(Line(inst, Some(sInst), Some(c) ))) when checkCondition c = true -> executeInstruction (executeInstruction state (SHIFT(sInst,false))) inst\r\n                // Shift:None/Some, Condition:False\r\n                | Some (Inst(Line(inst, _, Some(c) ))) when checkCondition c = false -> state \r\n                // Error cases\r\n                | None -> failwithf \"run time error: no instruction line found at address %A\" (state.RegMap.TryFind(R 15)) \r\n                | x -> failwithf \"run time error: instruction line not defined %A\" x \r\n            // Update PC \r\n            let newRegMap = \r\n                match outputState.RegMap.[R 15] with\r\n                | pc when pc = state.RegMap.[R 15] -> Map.add (R 15) (pc+4) outputState.RegMap\r\n                | _ -> outputState.RegMap // If PC has been changed, it means a branching operation has taken care of PC for us so no need +4\r\n            // Check if we have reached the end\r\n            match Addr(newRegMap.[R 15]) with\r\n            | pc when pc >= outputState.END -> {outputState with RegMap = newRegMap; State = RunEND}\r\n            | _ -> {outputState with RegMap = newRegMap}"]}