namespace ARM7TDMI

module Parser=
    open InstructionType
    open MachineState
   
    let whiteSpace = [| ' '; '\f'; '\t'; '\r'; '\n'; ',' |]
    
    /// matches string returning integer
    let (|IsLit|_|) (s:string) = 
        try 
            int s |> Some
        with _ -> None

    /// matches string returning integer
    let (|IsLabel|_|) (s:string) = 
        try 
            string s |> Some
        with _ -> None

    /// matches string returning integer
    let (|IsReg|_|) s =
        let ParseToReg =
            function
            | "R0" -> 0
            | "R1" -> 1
            | "R2" -> 2
            (*
            | "R3" -> R3
            | "R4" -> R4
            *)
            //exception
            | _ -> invalidOp "register does not exist"  
        try 
            ParseToReg s |> Some
        with _ -> None
    /// matches RegOrLit string returning the RegOrLit

    let (|IsRegOrLit|_|) s =
        let parse=
            function
            | IsReg reg -> Reg(R reg)
            | IsLit lit -> Lit(lit)
            | _ -> invalidOp "invalid input"
        try
            parse s |> Some
        with _ -> None

    let readAsm textInput = 
        let splitIntoLines (text:string) = 
            text.Split [|'\r'; '\n'|]
            |> Array.toList
            |> List.filter ((<>) "") // delete empty strings generated by default .Split function
        let splitIntoWords (line:string) = 
            line.Split whiteSpace
            |> Array.toList
            |> List.filter ((<>) "") // delete empty strings generated by default .Split function
        let executeWordsAsCommand = 
            function
            | [ "MOV"; IsReg reg1; IsRegOrLit reg2 ] -> ALU(MOV(R reg1,reg2),false)
            | [ "ADD"; IsReg reg1; IsReg reg2; IsRegOrLit reg3 ] -> ALU(ADD(R reg1,R reg2,reg3),false)
            //| [ IsLabel label ] -> ignore but no error
            | x -> failwithf "Unexpected match in parser: %s" x.[0]

        let instList = //: InstructionType list = 
            textInput
            |> splitIntoLines
            |> List.map splitIntoWords
            |> List.filter ((<>) [])
            |> List.map executeWordsAsCommand

        let init_memory = 
            seq { 0 .. instList.Length } 
            |> Seq.fold (fun (m: Map<Address, Memory>) i -> m.Add(Addr (i*4),Inst(instList.[i]))) Map.empty

        let init_reg = 
            [1..13] |> Seq.map (fun x -> (R x, 0)) |> Map.ofSeq

        { 
            PC = Addr 0
            End = Addr (4*instList.Length)
            RegMap = init_reg
            MemMap = init_memory
            Flags = {N=false; Z=false; C=false; V=false}
            State = RunOK
        }