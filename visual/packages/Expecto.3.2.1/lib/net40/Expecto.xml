<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Expecto</name></assembly>
<members>
<member name="T:Expecto.FTestsAttribute">
<summary>
 Allows to mark a test as FocusState.Focused (will be run and will change the behavior for
 all other tests marked as FocusState.Normal to be ignored)
 Is a fast way to exclude some tests from running.
 The test will run even if PTest is also present. Have priority over TestAttribute.
</summary>
</member>
<member name="T:Expecto.PTestsAttribute">
<summary>
 Allows to mark a test as Pending (will be skipped/ignored if no other TestAttribute is present)
 Is a fast way to exclude some tests from running.
 If FTest or Test is also present then this attribute will be ignored.
</summary>
</member>
<member name="T:Expecto.TestsAttribute">
<summary>
 Marks a top-level test for scanning
 The test will run even if PTest is also present.
</summary>
</member>
<member name="T:Expecto.Test.Sequenced">
<summary>
 Require sequenced for a Test (list or test code).
</summary>
</member>
<member name="T:Expecto.Test.TestLabel">
<summary>
 A labelling of a Test (list or test code).
</summary>
</member>
<member name="T:Expecto.Test.TestList">
<summary>
 A collection/list of tests.
</summary>
</member>
<member name="T:Expecto.Test.TestCase">
<summary>
 A test case is a function from unit to unit, that can be executed
 by Expecto to run the test code.
</summary>
</member>
<member name="T:Expecto.Test">
<summary>
 Test tree â€“ this is how you compose your tests as values. Since
 any of these can act as a test, you can pass any of these DU cases
 into a function that takes a Test.
</summary>
</member>
<member name="T:Expecto.FocusState.Focused">
<summary>
 The state of a test that will be evaluated
 All other test marked with Normal or Pending will be ignored
</summary>
</member>
<member name="T:Expecto.FocusState.Pending">
<summary>
 The state of a test that will be ignored by Expecto
</summary>
</member>
<member name="T:Expecto.FocusState.Normal">
<summary>
 The default state of a test that will be evaluated
</summary>
</member>
<member name="T:Expecto.FocusState">
<summary>
 The parent state (watching the tests as a tree structure) will influence
 the child tests state. By following rules, if parent test state is:
     - Focused will elevate all Normal child tests to Focused.
              Focused and Pending child tests will not change state(behavior)
     - Normal will not influence the child tests states(behavior).
     - Pending will elevate all Normal and Focused child tests to Pending.
              Pending child test will not change state(behavior)
</summary>
</member>
<member name="T:Expecto.TestCode">
<summary>
 Actual test function; either an async one, or a synchronous one.
</summary>
</member>
<member name="T:Expecto.Logging.CombiningTarget">
<summary>
 A logger to use for combining a number of other loggers
</summary>
</member>
<member name="T:Expecto.Logging.LiterateConsoleTarget">
<summary>
 Logs a line in a format that is great for human consumption,
 using console colours to enhance readability.
 Sample: [10:30:49 INF] User &quot;AdamC&quot; began the &quot;checkout&quot; process with 100 cart items
</summary>
</member>
<member name="P:Expecto.Logging.LoggingConfig.consoleSemaphore">
<summary>
 When composing apps from the outside-in (rather than having a unified
 framework with static/global config) with libraries (again, rather than
 a unified framework) like is best-practice, there&apos;s not necessarily a
 way to coordinate around the STDOUT and STDERR streams between
 different libraries running things on different threads. Use Logary&apos;s
 adapter to replace this semaphore with a global semaphore.
</summary>
</member>
<member name="P:Expecto.Logging.LoggingConfig.getLogger">
<summary>
 The `getLogger` function returns a logger that directly can be logged to.
</summary>
</member>
<member name="P:Expecto.Logging.LoggingConfig.timestamp">
<summary>
 The `timestamp` function should preferably be monotonic and not &apos;jumpy&apos;
 or take much time to call.
</summary>
</member>
<member name="M:Expecto.Logging.Logger.logWithAck(Expecto.Logging.LogLevel,Microsoft.FSharp.Core.FSharpFunc{Expecto.Logging.LogLevel,Expecto.Logging.Message})">
<summary>
 Logs with the specified log level with backpressure via the logging
 library&apos;s buffers *and* ACK/flush to the underlying message targets.

 Calls to this function will block the caller only while executing the
 callback (if the level is active).

 The returned async value will yield when the message has been flushed to
 the underlying message targets.

 You need to start the (cold) async value for the logging to happen.

 You should not do blocking/heavy operations in the callback.
</summary>
</member>
<member name="M:Expecto.Logging.Logger.log(Expecto.Logging.LogLevel,Microsoft.FSharp.Core.FSharpFunc{Expecto.Logging.LogLevel,Expecto.Logging.Message})">
<summary>
 Logs with the specified log level with backpressure via the logging
 library&apos;s buffers.

 Calls to this function will block the caller only while executing the
 callback (if the level is active).

 The returned async value will yield when the message has been added to
 the buffers of the logging library.

 You need to start the (cold) async value for the logging to happen.

 You should not do blocking/heavy operations in the callback.
</summary>
</member>
<member name="P:Expecto.Logging.Logger.name">
<summary>
 Gets the name of the logger instance.
</summary>
</member>
<member name="T:Expecto.Logging.Logger">
<summary>
 The logger is the interface for calling code to use for logging. Its
 different functions have different semantics - read the docs for each
 method to choose the right one for your use-case.
</summary>
</member>
<member name="P:Expecto.Logging.Message.level">
<summary>
 How important? See the docs on the LogLevel type for details.
</summary>
</member>
<member name="P:Expecto.Logging.Message.timestamp">
<summary>
 When? nanoseconds since UNIX epoch.
</summary>
</member>
<member name="P:Expecto.Logging.Message.fields">
<summary>
 The structured-logging data.
</summary>
</member>
<member name="P:Expecto.Logging.Message.value">
<summary>
 The main value for this metric or event. Either a Gauge or an Event. (A
 discriminated union type)
</summary>
</member>
<member name="P:Expecto.Logging.Message.name">
<summary>
 The &apos;path&apos; or &apos;name&apos; of this data point. Do not confuse template in
 (Event template) = message.value
</summary>
</member>
<member name="P:Expecto.Logging.Message.utcTicks">
<summary>
 Gets the ticks for UTC since 0001-01-01 00:00:00 for this message. You
 can pass this value into a DateTimeOffset c&apos;tor
</summary>
</member>
<member name="P:Expecto.Logging.Message.README">
<summary>
 If you&apos;re looking for how to transform the Message&apos;s fields, then use the
 module methods rather than instance methods, since you&apos;ll be creating new
 values rather than changing an existing value.
</summary>
</member>
<member name="T:Expecto.Logging.Message">
<summary>
 This is record that is logged. It&apos;s capable of representing both metrics
 (gauges) and events. See https://github.com/logary/logary for details.
</summary>
</member>
<member name="T:Expecto.Logging.EpochNanoSeconds">
<summary>
 The # of nanoseconds after 1970-01-01 00:00:00.
</summary>
</member>
<member name="T:Expecto.Logging.PointValue.Gauge">
<summary>
 This is as value for a metric, with a unit attached. The unit can be
 something like Seconds or Hz.
</summary>
</member>
<member name="T:Expecto.Logging.PointValue.Event">
<summary>
 An event is what it sounds like; something occurred and needs to be
 logged. Its field is named &apos;template&apos; because it should not be interpolated
 with values; instead these values should be put in the &apos;fields&apos; field of
 the Message.
</summary>
</member>
<member name="T:Expecto.Logging.PointValue">
<summary>
 Represents a logged value; either a Gauge or an Event.
</summary>
</member>
<member name="T:Expecto.Logging.LogLevel.Fatal">
<summary>
 The log message denotes a fatal error which cannot be recovered from. The
 service should be shut down. Human corrective action is needed.
</summary>
</member>
<member name="T:Expecto.Logging.LogLevel.Error">
<summary>
 The log message is at an error level, meaning an unhandled exception
 occurred at a location where it is deemed important to keeping the service
 running. A human should take corrective action.
</summary>
</member>
<member name="T:Expecto.Logging.LogLevel.Warn">
<summary>
 The log message is a warning; e.g. there was an unhandled exception or
 an even occurred which was unexpected. Sometimes human corrective action
 is needed.
</summary>
</member>
<member name="T:Expecto.Logging.LogLevel.Info">
<summary>
 The log message is informational; e.g. the service started, stopped or
 some important business event occurred.
</summary>
</member>
<member name="T:Expecto.Logging.LogLevel.Debug">
<summary>
 The log message is at a default level, debug level. Useful for shipping to
 infrastructure that further processes it, but not so useful for human
 inspection in its raw format, except during development.
</summary>
</member>
<member name="T:Expecto.Logging.LogLevel.Verbose">
<summary>
 The log message is not that important; can be used for intricate debugging.
</summary>
</member>
<member name="M:Expecto.Logging.LogLevel.toInt">
<summary>
 Turn the LogLevel into an integer
</summary>
</member>
<member name="M:Expecto.Logging.LogLevel.ofString(System.String)">
<summary>
 Converts the string passed to a Loglevel.
</summary>
</member>
<member name="M:Expecto.Logging.LogLevel.ofInt(System.Int32)">
<summary>
 Turn an integer into a LogLevel
</summary>
</member>
<member name="M:Expecto.Logging.LogLevel.ToString">
<summary>
 Converts the LogLevel to a string
</summary>
</member>
<member name="T:Expecto.Logging.LogLevel">
<summary>
 The log level denotes how &apos;important&apos; the gauge or event message is.
</summary>
</member>
<member name="M:Expecto.Logging.MessageModule.addExn``1(``0,Expecto.Logging.Message)">
<summary>
 Adds an exception to the Message, to the &apos;errors&apos; field, inside a list.
</summary>
</member>
<member name="M:Expecto.Logging.MessageModule.setLevel(Expecto.Logging.LogLevel,Expecto.Logging.Message)">
<summary>
 Sets the level on the log message.
</summary>
</member>
<member name="M:Expecto.Logging.MessageModule.setTimestamp(System.Int64,Expecto.Logging.Message)">
<summary>
 Sets the timestamp on the log message.
</summary>
</member>
<member name="M:Expecto.Logging.MessageModule.setFieldValue``1">
<summary>
 Alias to `setField`
</summary>
</member>
<member name="M:Expecto.Logging.MessageModule.setField(System.String,System.Object,Expecto.Logging.Message)">
<summary>
 Sets the value of the field on the log message.
</summary>
</member>
<member name="M:Expecto.Logging.MessageModule.setSingleName(System.String,Expecto.Logging.Message)">
<summary>
 Sets the name as a single string; if this string contains dots, the string
 will be split on these dots.
</summary>
</member>
<member name="M:Expecto.Logging.MessageModule.setNameEnding(System.String,Expecto.Logging.Message)">
<summary>
 Sets the final portion o fthe name of the Message.
</summary>
</member>
<member name="M:Expecto.Logging.MessageModule.setName(System.String[],Expecto.Logging.Message)">
<summary>
 Sets the name/path of the log message.
</summary>
</member>
<member name="M:Expecto.Logging.MessageModule.gauge(System.Int64,System.String)">
<summary>
 Create a new instantaneous value in a log message.
</summary>
</member>
<member name="M:Expecto.Logging.MessageModule.eventX(System.String,Expecto.Logging.LogLevel)">
<summary>
 Create a new event log message â€“ like `event` but with parameters flipped.
 Useful to use with `Logger.log` with point-free style, to reduce the
 noise. E.g. `logger.logVerbose (eventX &quot;Returned {code}&quot; &gt;&gt; setField &quot;code&quot; 24)`
</summary>
</member>
<member name="M:Expecto.Logging.MessageModule.event(Expecto.Logging.LogLevel,System.String)">
<summary>
 Create a new event log message.
</summary>
</member>
<member name="T:Expecto.Logging.MessageModule">
<summary>
 The Message module contains functions that can help callers compose messages. This
 module is especially helpful to open to make calls into Logary&apos;s facade small.
</summary>
</member>
<member name="M:Expecto.Logging.Log.createHiera(System.String[])">
<summary>
 Create an hierarchically named logger
</summary>
</member>
<member name="M:Expecto.Logging.Log.create(System.String)">
<summary>
 Create a named logger. Full stop (.) acts as segment delimiter in the
 hierachy of namespaces and loggers.
</summary>
</member>
<member name="T:Expecto.Logging.Log">
<summary>
 Module for acquiring static loggers (when you don&apos;t want or can&apos;t)
 pass loggers as values.
</summary>
</member>
<member name="M:Expecto.Logging.Targets.create(Expecto.Logging.LogLevel,System.String[])">
<summary>
 Create a new target. Prefer `Log.create` in your own libraries, or let the
 composing app replace your target instance through your configuration.

 Will log to console (colourised) by default, and also to the output window
 in your IDE if you specify a level below Info.
</summary>
</member>
<member name="T:Expecto.Logging.Targets">
<summary>
 &quot;Shortcut&quot; for creating targets; useful at the top-level configuration point of
 your library.
</summary>
</member>
<member name="T:Expecto.Logging.Global.Flyweight">
<summary>
 The flyweight just references the current configuration. If you want
 multiple per-process logging setups, then don&apos;t use the static methods,
 but instead pass a Logger instance around, setting the name field of the
 Message value you pass into the logger.
</summary>
</member>
<member name="M:Expecto.Logging.Global.initialise(Expecto.Logging.LoggingConfig)">
<summary>
 Call from the initialisation of your library. Initialises the
 Logary.Facade globally/per process.
</summary>
</member>
<member name="M:Expecto.Logging.Global.lockSem``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Run the passed function under the console semaphore lock.
</summary>
</member>
<member name="M:Expecto.Logging.Global.semaphore">
<summary>
 Returns the synchronisation object to use when printing to the console.
</summary>
</member>
<member name="P:Expecto.Logging.Global.defaultConfig">
<summary>
 The global default configuration, which logs to Console at Info level.
</summary>
</member>
<member name="P:Expecto.Logging.Global.consoleSemaphore">
<summary>
 This is the global semaphore for colourising the console output. Ensure
 that the same semaphore is used across libraries by using the Logary
 Facade Adapter in the final composing app/service.
</summary>
</member>
<member name="M:Expecto.Logging.Formatting.defaultFormatter(Expecto.Logging.Message)">
<summary>
 let the ISO8601 love flow
</summary>
</member>
<member name="M:Expecto.Logging.Formatting.literateDefaultTokeniser(Expecto.Logging.Literate.LiterateOptions,Expecto.Logging.Message)">
<summary>
 Split a structured message up into theme-able parts (tokens), allowing the
 final output to display to a user with colours to enhance readability.
</summary>
</member>
<member name="T:Expecto.Logging.Formatting">
<summary>
 Internal module for formatting text for printing to the console.
</summary>
</member>
<member name="M:Expecto.Logging.FsMtParser.parseParts(System.String,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{Expecto.Logging.FsMtParser.Property,Microsoft.FSharp.Core.Unit})">
<summary>
 Parses template strings such as &quot;Hello, {PropertyWithFormat:##.##}&quot;
 and calls the &apos;foundTextF&apos; or &apos;foundPropF&apos; functions as the text or
 property tokens are encountered.
</summary>
</member>
<member name="P:Expecto.Logging.Literals.FacadeLanguage">
<summary>
 What language this Facade has. This controls things like naming standards.
</summary>
</member>
<member name="P:Expecto.Logging.Literals.FacadeVersion">
<summary>
 What version of the Facade is this. This is a major version that allows the Facade
 adapter to choose how it handles the API.
</summary>
</member>
<member name="T:Expecto.Logging.Literals">
<summary>
 Module that contains the &apos;known&apos; keys of the Maps in the Message type&apos;s
 fields/runtime data.
</summary>
</member>
<member name="T:Expecto.Logging.Literate.LiterateToken">
<summary>
 The output tokens, which can be potentially coloured.
</summary>
</member>
<member name="M:Expecto.Logging.LoggerEx.Logger.logSimple(Expecto.Logging.Logger,Expecto.Logging.Message)">
<summary>
 Log a message, but don&apos;t synchronously wait for the message to be placed
 inside the logging library&apos;s buffers. Instead the message will be added
 to the logging library&apos;s buffers asynchronously (with respect to the
 caller) with a timeout of 5 seconds, and will then be dropped.

 This is the way we avoid the unbounded buffer problem.

 If you have dropped messages, they will be logged to STDERR. You should load-
 test your app to ensure that your targets can send at a rate high enough
 without dropping messages.

 It&apos;s recommended to have alerting on STDERR.
</summary>
</member>
<member name="M:Expecto.Logging.LoggerEx.Logger.fatalWithBP(Expecto.Logging.Logger,Microsoft.FSharp.Core.FSharpFunc{Expecto.Logging.LogLevel,Expecto.Logging.Message})">
<summary>
 Log with backpressure
</summary>
</member>
<member name="M:Expecto.Logging.LoggerEx.Logger.errorWithBP(Expecto.Logging.Logger,Microsoft.FSharp.Core.FSharpFunc{Expecto.Logging.LogLevel,Expecto.Logging.Message})">
<summary>
 Log with backpressure
</summary>
</member>
<member name="M:Expecto.Logging.LoggerEx.Logger.warnWithBP(Expecto.Logging.Logger,Microsoft.FSharp.Core.FSharpFunc{Expecto.Logging.LogLevel,Expecto.Logging.Message})">
<summary>
 Log with backpressure
</summary>
</member>
<member name="M:Expecto.Logging.LoggerEx.Logger.infoWithBP(Expecto.Logging.Logger,Microsoft.FSharp.Core.FSharpFunc{Expecto.Logging.LogLevel,Expecto.Logging.Message})">
<summary>
 Log with backpressure
</summary>
</member>
<member name="M:Expecto.Logging.LoggerEx.Logger.debugWithBP(Expecto.Logging.Logger,Microsoft.FSharp.Core.FSharpFunc{Expecto.Logging.LogLevel,Expecto.Logging.Message})">
<summary>
 Log with backpressure
</summary>
</member>
<member name="M:Expecto.Logging.LoggerEx.Logger.verboseWithBP(Expecto.Logging.Logger,Microsoft.FSharp.Core.FSharpFunc{Expecto.Logging.LogLevel,Expecto.Logging.Message})">
<summary>
 Log with backpressure
</summary>
</member>
<member name="T:Expecto.Logging.LoggerEx">
<summary>
 Syntactic sugar on top of Logger for F# libraries.
</summary>
</member>
<member name="M:Expecto.Logging.DateTimeOffset.ticksUTC(System.Int64)">
<summary>
 Get the DateTimeOffset ticks from EpochNanoSeconds
</summary>
</member>
<member name="M:Expecto.Logging.DateTimeOffset.timestamp(System.DateTimeOffset)">
<summary>
 Get the Logary timestamp off the DateTimeOffset.
</summary>
</member>
<member name="T:Expecto.Logging.DateTimeOffset">
<summary>
 Helper functions for transforming DateTimeOffset to timestamps in unix epoch.
</summary>
</member>
<member name="M:Expecto.Logging.DateTime.ticksUTC(System.Int64)">
<summary>
 Get the DateTimeOffset ticks off from the EpochNanoSeconds.
</summary>
</member>
<member name="M:Expecto.Logging.DateTime.timestamp(System.DateTime)">
<summary>
 Get the Logary timestamp off the DateTime.
</summary>
</member>
<member name="T:Expecto.Logging.DateTime">
<summary>
 Helper functions for transforming DateTime to timestamps in unix epoch.
</summary>
</member>
<member name="M:Expecto.Tests.runTestsInAssembly(Expecto.Impl.ExpectoConfig,System.String[])">
<summary>
 Runs tests in this assembly with the supplied command-line options.
 Returns 0 if all tests passed, otherwise 1
</summary>
</member>
<member name="M:Expecto.Tests.runTestsWithArgs(Expecto.Impl.ExpectoConfig,System.String[],Expecto.Test)">
<summary>
 Runs all given tests with the supplied command-line options.
 Returns 0 if all tests passed, otherwise 1
</summary>
</member>
<member name="M:Expecto.Tests.runTests(Expecto.Impl.ExpectoConfig,Expecto.Test)">
<summary>
 Runs tests with the supplied options.
 Returns 0 if all tests passed, otherwise 1
</summary>
</member>
<member name="M:Expecto.Tests.listTests(Expecto.Test)">
<summary>
 Prints out names of all tests for given test suite.
</summary>
</member>
<member name="P:Expecto.Tests.defaultConfig">
<summary>
 The default configuration for Expecto.
</summary>
</member>
<member name="M:Expecto.Tests.run(Expecto.Impl.ExpectoConfig,Expecto.Test)">
<summary>
 Runs the passed tests
</summary>
</member>
<member name="M:Expecto.Tests.testParam``1(``0)">
<summary>
 Applies a value to a list of partial tests
</summary>
</member>
<member name="M:Expecto.Tests.testFixture``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
<summary>
 Applies a function to a list of values to build test cases
</summary>
</member>
<member name="M:Expecto.Tests.testSequenced(Expecto.Test)">
<summary>
 Test case or list needs to run sequenced. Use for any benchmark code or
 for tests using `Expect.isFasterThan`
</summary>
</member>
<member name="M:Expecto.Tests.ptestCaseAsync(System.String,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit})">
<summary>
 Builds an async test case that will be ignored by Expecto
</summary>
</member>
<member name="M:Expecto.Tests.ptestCase(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Builds a test case that will be ignored by Expecto
</summary>
</member>
<member name="M:Expecto.Tests.ftestCaseAsync(System.String,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit})">
<summary>
 Builds an async test case that will make Expecto to ignore other unfocused tests
</summary>
</member>
<member name="M:Expecto.Tests.ftestCase(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Builds a test case that will make Expecto to ignore other unfocused tests
</summary>
</member>
<member name="M:Expecto.Tests.testCaseAsync(System.String,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit})">
<summary>
 Builds an async test case
</summary>
</member>
<member name="M:Expecto.Tests.testCase(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Builds a test case that will be ignored by Expecto if exists focused
 tests and none of the parents is focused
</summary>
</member>
<member name="M:Expecto.Tests.ptestList(System.String,Microsoft.FSharp.Collections.FSharpList{Expecto.Test})">
<summary>
 Builds a list/group of tests that will be ignored by Expecto
</summary>
</member>
<member name="M:Expecto.Tests.ftestList(System.String,Microsoft.FSharp.Collections.FSharpList{Expecto.Test})">
<summary>
 Builds a list/group of tests that will make Expecto to ignore other unfocused tests
</summary>
</member>
<member name="M:Expecto.Tests.testList(System.String,Microsoft.FSharp.Collections.FSharpList{Expecto.Test})">
<summary>
 Builds a list/group of tests that will be ignored by Expecto if exists
 focused tests and none of the parents is focused
</summary>
</member>
<member name="M:Expecto.Tests.skiptestf``2(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
<summary>
 Skip this test
</summary>
</member>
<member name="M:Expecto.Tests.skiptest``1(System.String)">
<summary>
 Skip this test
</summary>
</member>
<member name="M:Expecto.Tests.failtestNoStackf``2(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
<summary>
 Fail this test
</summary>
</member>
<member name="M:Expecto.Tests.failtestNoStack``1(System.String)">
<summary>
 Fail this test
</summary>
</member>
<member name="M:Expecto.Tests.failtestf``2(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
<summary>
 Fail this test
</summary>
</member>
<member name="M:Expecto.Tests.failtest``1(System.String)">
<summary>
 Fail this test
</summary>
</member>
<member name="M:Expecto.Tests.ExpectoConfigModule.fillFromArgs(Expecto.Impl.ExpectoConfig)">
<summary>
 Parses command-line arguments into a config. This allows you to
 override the config from the command line, rather than having
 to go into the compiled code to change how they are being run.
 Also checks if tests should be run or only listed
</summary>
</member>
<member name="P:Expecto.Impl.ExpectoConfig.locate">
<summary>
 Optional function used for finding source code location of test
 Defaults to empty source code
</summary>
</member>
<member name="P:Expecto.Impl.ExpectoConfig.verbosity">
<summary>
 Verbosity level (default: Info)
</summary>
</member>
<member name="P:Expecto.Impl.ExpectoConfig.printer">
<summary>
 Allows the test printer to be parametised to your liking.
</summary>
</member>
<member name="P:Expecto.Impl.ExpectoConfig.filter">
<summary>
 An optional filter function. Useful if you only would
 like to run a subset of all the tests defined in your assembly.
</summary>
</member>
<member name="P:Expecto.Impl.ExpectoConfig.failOnFocusedTests">
<summary>
 Whether to make the test runner fail if focused tests exist.
 This can be used from CI servers to ensure no focused tests are
 commited and therefor all tests are run.
</summary>
</member>
<member name="P:Expecto.Impl.ExpectoConfig.parallelWorkers">
<summary>
 Number of parallel workers. Defaults to the number of
 logical processors.
</summary>
</member>
<member name="P:Expecto.Impl.ExpectoConfig.parallel">
<summary>
 Whether to run the tests in parallel. Defaults to
 true, because your code should not mutate global
 state by default.
</summary>
</member>
<member name="P:Expecto.Impl.WrappedFocusedState.ShouldSkipEvaluation">
<summary>
 Used to check if a test should be run and to generate a proper status messsage
</summary>
</member>
<member name="M:Expecto.Impl.WrappedFocusedState.WrapStates(Microsoft.FSharp.Collections.FSharpList{Expecto.FlatTest})">
<summary>
 tests: FlatTest list -&gt; WrappedFlatTest list
</summary>
</member>
<member name="P:Expecto.Impl.TestPrinters.summary">
<summary>
 Prints a summary given the test result counts
</summary>
</member>
<member name="P:Expecto.Impl.TestPrinters.exn">
<summary>
 test name -&gt; exception -&gt; time taken -&gt; unit
</summary>
</member>
<member name="P:Expecto.Impl.TestPrinters.failed">
<summary>
 test name -&gt; other message -&gt; time taken -&gt; unit
</summary>
</member>
<member name="P:Expecto.Impl.TestPrinters.ignored">
<summary>
 test name -&gt; ignore message -&gt; unit
</summary>
</member>
<member name="P:Expecto.Impl.TestPrinters.passed">
<summary>
 test name -&gt; time taken -&gt; unit
</summary>
</member>
<member name="P:Expecto.Impl.TestPrinters.info">
<summary>
 info
</summary>
</member>
<member name="P:Expecto.Impl.TestPrinters.beforeEach">
<summary>
 Called before atomic test (TestCode) is executed.
</summary>
</member>
<member name="P:Expecto.Impl.TestPrinters.beforeRun">
<summary>
 Called before a test run (e.g. at the top of your main function)
</summary>
</member>
<member name="T:Expecto.Impl.TestPrinters">
<summary>
 Hooks to print report through test run
</summary>
</member>
<member name="M:Expecto.Impl.passesFocusTestCheck(Expecto.Test)">
<summary>
 When the failOnFocusedTests switch is activated this function that no
 focused tests exist.

 Returns true if the check passes, otherwise false.
</summary>
</member>
<member name="M:Expecto.Impl.testFromThisAssembly">
<summary>
 Scan tests marked with TestsAttribute from entry assembly
</summary>
</member>
<member name="P:Expecto.Impl.testFromAssembly">
<summary>
 Scan tests marked with TestsAttribute from an assembly
</summary>
</member>
<member name="M:Expecto.Impl.testFromAssemblyWithFilter(Microsoft.FSharp.Core.FSharpFunc{System.Type,System.Boolean},System.Reflection.Assembly)">
<summary>
 Scan filtered tests marked with TestsAttribute from an assembly
</summary>
</member>
<member name="M:Expecto.Impl.runEval(Expecto.Impl.ExpectoConfig,Expecto.Test)">
<summary>
 Runs tests, returns error code
</summary>
</member>
<member name="M:Expecto.Impl.evalPar(Expecto.Impl.ExpectoConfig,Expecto.Test)">
<summary>
 Evaluates tests.
</summary>
</member>
<member name="M:Expecto.Impl.eval``1(Expecto.Impl.ExpectoConfig,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Expecto.Impl.WrappedFlatTest,Microsoft.FSharp.Control.FSharpAsync{Expecto.Impl.TestRunResult}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Expecto.Impl.WrappedFlatTest},``0}},Expecto.Test)">
<summary>
 Runs a tree of tests, with parameterized printers (progress indicators) and traversal.
 Returns list of results.
</summary>
</member>
<member name="M:Expecto.Impl.evalTestList``1(Expecto.Impl.ExpectoConfig,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Expecto.Impl.WrappedFlatTest,Microsoft.FSharp.Control.FSharpAsync{Expecto.Impl.TestRunResult}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Expecto.Impl.WrappedFlatTest},``0}})">
<summary>
 Runs a list of tests, with parameterized printers (progress indicators) and traversal.
 Returns list of results.
</summary>
</member>
<member name="M:Expecto.TestModule.timeout(System.Int32,Expecto.TestCode)">
<summary>
 Applies a timeout to a test.
</summary>
</member>
<member name="M:Expecto.TestModule.filter(Microsoft.FSharp.Core.FSharpFunc{System.String,System.Boolean})">
<summary>
 Filter tests by name.
</summary>
</member>
<member name="M:Expecto.TestModule.replaceTestCode(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{Expecto.TestCode,Expecto.Test}},Expecto.Test)">
<summary>
 Recursively replaces TestCodes in a Test.
 Check translateFocusState for focus state behaviour description.
</summary>
</member>
<member name="M:Expecto.TestModule.translateFocusState(Expecto.FocusState,Expecto.Test)">
<summary>
 Change the FocusState by appling the old state to a new state
 Note: this is not state replacement!!!
 Used in replaceTestCode and the order is intended for scenario:
  1. User wants to automate some tests and his intent is not to change
      the test state (use Normal), so this way the current state will be preserved
 Don&apos;t see the use case: the user wants to automate some tests and wishes
 to change the test states
</summary>
</member>
<member name="M:Expecto.TestModule.replaceFocusState(Expecto.FocusState,Expecto.Test)">
<summary>
 Enforce a FocusState on a test by replacing the current state
 Is not used (against YAGNI), but is here to make it clear for intellisense discovery
 that the translateFocusState is not intended as replacement
</summary>
</member>
<member name="M:Expecto.TestModule.wrap(Microsoft.FSharp.Core.FSharpFunc{Expecto.TestCode,Expecto.TestCode},Expecto.Test)">
<summary>
 Recursively maps all TestCodes in a Test
</summary>
</member>
<member name="P:Expecto.TestModule.toTestCodeList">
<summary>
 Flattens a tree of tests
</summary>
</member>
<member name="M:Expecto.TestModule.computeChildFocusState(Expecto.FocusState,Expecto.FocusState)">
<summary>
 Compute the child test state based on parent test state
</summary>
</member>
<member name="M:Expecto.Async.parallelLimit``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Traverses the list of async, spawning them with Async.Start and
</summary>
</member>
<member name="M:Expecto.Performance.timeCompare``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0}},``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0}},``0})">
<summary>
 Time comparison for two given functions to a 99.99% confidence level.
</summary>
</member>
<member name="M:Expecto.Performance.timeStatistics``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``2})">
<summary>
 Time statistics for a given function accurate to a mean standard error of 0.1%.
</summary>
</member>
<member name="M:Expecto.Performance.Statistics.welchTest(Expecto.Performance.Statistics.WelchStatistic)">
<summary>
 Welch&apos;s t-test for a given Welch statistic using a 0.01% confidence level.
</summary>
</member>
<member name="M:Expecto.Performance.Statistics.welchStatistic(Expecto.Performance.SampleStatistics,Expecto.Performance.SampleStatistics)">
<summary>
 Welch&apos;s t-test statistic for two given sample statistics.
</summary>
</member>
<member name="P:Expecto.Performance.Statistics.tInv99">
<summary>
 Student&apos;s t-distribution inverse for the 99.99% probability by degrees of freedom.
</summary>
</member>
<member name="P:Expecto.Performance.Statistics.tInv01">
<summary>
 Student&apos;s t-distribution inverse for the 00.01% probability by degrees of freedom.
</summary>
</member>
<member name="M:Expecto.Performance.Statistics.scale(System.Double,Expecto.Performance.SampleStatistics)">
<summary>
 Scale the statistics for the given underlying random variable change of scale.
</summary>
</member>
<member name="M:Expecto.Performance.Statistics.sampleStatistics``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Online statistics sequence for a given sample sequence.
</summary>
</member>
<member name="M:Expecto.Expect.isFasterThan``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},System.String)">
<summary>
 Expects function `f1` is faster than `f2`. Statistical test to 99.99%
 confidence level.
</summary>
</member>
<member name="M:Expecto.Expect.isFasterThanSub``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0}},``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0}},``0},System.String)">
<summary>
 Expects function `f1` is faster than `f2`. Measurer used to measure only a
 subset of the functions. Statistical test to 99.99% confidence level.
</summary>
</member>
<member name="M:Expecto.Expect.streamsEqual(System.IO.Stream,System.IO.Stream,System.String)">
<summary>
 Expect the streams to byte-wise equal.
</summary>
</member>
<member name="M:Expecto.Expect.stringHasLength(System.String,System.Int32,System.String)">
<summary>
 Expect the string `subject` to have length equals `length`. If it does not
 then fail with `format` as an error message together with a description
 of `subject` and `length`.
</summary>
</member>
<member name="M:Expecto.Expect.stringEnds(System.String,System.String,System.String)">
<summary>
 Expect the string `subject` to end with `suffix`. If it does not
 then fail with `format` as an error message together with a description
 of `subject` and `suffix`.
</summary>
</member>
<member name="M:Expecto.Expect.stringStarts(System.String,System.String,System.String)">
<summary>
 Expect the string `subject` to start with `prefix`. If it does not
 then fail with `format` as an error message together with a description
 of `subject` and `prefix`.
</summary>
</member>
<member name="M:Expecto.Expect.stringContains(System.String,System.String,System.String)">
<summary>
 Expect the string `subject` to contain `substring` as part of itself.
 If it does not, then fail with `format` and `subject` and `substring`
 as part of the error message.
</summary>
</member>
<member name="M:Expecto.Expect.isDescending``1(System.Collections.Generic.IEnumerable{``0},System.String)">
<summary>
 Expect the sequence `subject` to be descending. If it does not
 then fail with `format` as an error message.
</summary>
</member>
<member name="M:Expecto.Expect.isAscending``1(System.Collections.Generic.IEnumerable{``0},System.String)">
<summary>
 Expect the sequence `subject` to be ascending. If it does not
 then fail with `format` as an error message.
</summary>
</member>
<member name="M:Expecto.Expect.sequenceStarts``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.String)">
<summary>
 Expect the sequence `subject` to start with `prefix`. If it does not
 then fail with `format` as an error message together with a description
 of `subject` and `prefix`.
</summary>
</member>
<member name="M:Expecto.Expect.sequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.String)">
<summary>
 Expects the `actual` sequence to equal the `expected` one.
</summary>
</member>
<member name="M:Expecto.Expect.distribution``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Collections.FSharpMap{``0,System.UInt32},System.String)">
<summary>
 Expects the `actual` sequence to contain all elements from `expected` map,
 first element in every tuple from `expected` map means item which should be
 presented in `actual` sequence, the second element means an expected number of occurrences
 of this item in sequence.
 Function is not taking into account an order of elements.
 Calling this function will enumerate both sequences; they have to be finite.
</summary>
</member>
<member name="M:Expecto.Expect.containsAll``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.String)">
<summary>
 Expects the `actual` sequence to contain all elements from `expected`
 it doesn&apos;t take into account number of occurances of characters
 sequence (not taking into account an order of elements). Calling this
 function will enumerate both sequences; they have to be finite.
</summary>
</member>
<member name="M:Expecto.Expect.contains``1(System.Collections.Generic.IEnumerable{``0},``0,System.String)">
<summary>
 Expects the `sequence` to contain the `element`.
</summary>
</member>
<member name="M:Expecto.Expect.isTrue(System.Boolean,System.String)">
<summary>
 Expects the value to be true.
</summary>
</member>
<member name="M:Expecto.Expect.isFalse(System.Boolean,System.String)">
<summary>
 Expects the value to be false.
</summary>
</member>
<member name="M:Expecto.Expect.notEqual``1(``0,``0,System.String)">
<summary>
 Expects the two values not to equal each other.
</summary>
</member>
<member name="M:Expecto.Expect.equal``1(``0,``0,System.String)">
<summary>
 Expects the two values to equal each other.
</summary>
</member>
<member name="M:Expecto.Expect.floatClose(Expecto.Accuracy,System.Double,System.Double,System.String)">
<summary>
 Expects `actual` and `expected` (that are both floats) to be within a
 given `accuracy`.
</summary>
</member>
<member name="M:Expecto.Expect.floatEqual(System.Double,System.Double,Microsoft.FSharp.Core.FSharpOption{System.Double},System.String)">
<summary>
 Expects `actual` and `expected` (that are both floats) to equal within a
 given `epsilon`.
</summary>
</member>
<member name="M:Expecto.Expect.isGreaterThanOrEqual``1(``0,``0,System.String)">
<summary>
 Expects `a` &gt;= `b`.
</summary>
</member>
<member name="M:Expecto.Expect.isGreaterThan``1(``0,``0,System.String)">
<summary>
 Expects `a` &gt; `b`.
</summary>
</member>
<member name="M:Expecto.Expect.isLessThanOrEqual``1(``0,``0,System.String)">
<summary>
 Expects `a` &lt;= `b`.
</summary>
</member>
<member name="M:Expecto.Expect.isLessThan``1(``0,``0,System.String)">
<summary>
 Expects `a` to be less than `b`.
</summary>
</member>
<member name="M:Expecto.Expect.isNull``1(``0,System.String)">
<summary>
 Expects the value to be null.
</summary>
</member>
<member name="M:Expecto.Expect.isNotNull``1(``0,System.String)">
<summary>
 Expects the value not to be null.
</summary>
</member>
<member name="M:Expecto.Expect.isChoice2Of2``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1},System.String)">
<summary>
 Expects the value to be a Choice2Of2 value.
</summary>
</member>
<member name="M:Expecto.Expect.isChoice1Of2``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1},System.String)">
<summary>
 Expects the value to be a Choice1Of2 value.
</summary>
</member>
<member name="M:Expecto.Expect.isSome``1(Microsoft.FSharp.Core.FSharpOption{``0},System.String)">
<summary>
 Expects the value to be a Some _ value.
</summary>
</member>
<member name="M:Expecto.Expect.isNone``1(Microsoft.FSharp.Core.FSharpOption{``0},System.String)">
<summary>
 Expects the value to be a None value.
</summary>
</member>
<member name="M:Expecto.Expect.throwsT``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},System.String)">
<summary>
 Expects the passed function to throw `&apos;texn`.
</summary>
</member>
<member name="M:Expecto.Expect.throwsC``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``0})">
<summary>
 Expects f to throw, and calls `cont` with its exception.
</summary>
</member>
<member name="M:Expecto.Expect.throws(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},System.String)">
<summary>
 Expects f to throw an exception.
</summary>
</member>
<member name="T:Expecto.Expect">
<summary>
 A module for specifying what you expect from the values generated
 by your tests.
</summary>
</member>
</members>
</doc>
